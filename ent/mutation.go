// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"orse/ent/menu"
	"orse/ent/order"
	"orse/ent/orderamounts"
	"orse/ent/orderdelivery"
	"orse/ent/orderitem"
	"orse/ent/orderpay"
	"orse/ent/ordersetting"
	"orse/ent/predicate"
	"orse/ent/product"
	"orse/ent/productattributekey"
	"orse/ent/productattributevalue"
	"orse/ent/productcate"
	"orse/ent/productspecs"
	"orse/ent/productspecsitem"
	"orse/ent/property"
	"orse/ent/user"
	"orse/ent/userdetail"
	"sync"
	"time"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMenu                  = "Menu"
	TypeOrder                 = "Order"
	TypeOrderAmounts          = "OrderAmounts"
	TypeOrderDelivery         = "OrderDelivery"
	TypeOrderItem             = "OrderItem"
	TypeOrderPay              = "OrderPay"
	TypeOrderSetting          = "OrderSetting"
	TypeProduct               = "Product"
	TypeProductAttributeKey   = "ProductAttributeKey"
	TypeProductAttributeValue = "ProductAttributeValue"
	TypeProductCate           = "ProductCate"
	TypeProductSpecs          = "ProductSpecs"
	TypeProductSpecsItem      = "ProductSpecsItem"
	TypeUser                  = "User"
	TypeUserDetail            = "UserDetail"
)

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	title           *string
	name            *string
	url             *string
	level           *int
	addlevel        *int
	sort            *int
	addsort         *int
	status          *property.Status
	icon            *string
	hidden          *property.Status
	desc            *string
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetTitle sets the "title" field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetURL sets the "url" field.
func (m *MenuMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MenuMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *MenuMutation) ClearURL() {
	m.url = nil
	m.clearedFields[menu.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *MenuMutation) URLCleared() bool {
	_, ok := m.clearedFields[menu.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *MenuMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, menu.FieldURL)
}

// SetLevel sets the "level" field.
func (m *MenuMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *MenuMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *MenuMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *MenuMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *MenuMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MenuMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(pr property.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r property.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetHidden sets the "hidden" field.
func (m *MenuMutation) SetHidden(pr property.Status) {
	m.hidden = &pr
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *MenuMutation) Hidden() (r property.Status, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHidden(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *MenuMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[menu.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *MenuMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[menu.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *MenuMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, menu.FieldHidden)
}

// SetDesc sets the "desc" field.
func (m *MenuMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MenuMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *MenuMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[menu.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *MenuMutation) DescCleared() bool {
	_, ok := m.clearedFields[menu.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *MenuMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, menu.FieldDesc)
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.url != nil {
		fields = append(fields, menu.FieldURL)
	}
	if m.level != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.hidden != nil {
		fields = append(fields, menu.FieldHidden)
	}
	if m.desc != nil {
		fields = append(fields, menu.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldName:
		return m.Name()
	case menu.FieldURL:
		return m.URL()
	case menu.FieldLevel:
		return m.Level()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldHidden:
		return m.Hidden()
	case menu.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldURL:
		return m.OldURL(ctx)
	case menu.FieldLevel:
		return m.OldLevel(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldHidden:
		return m.OldHidden(ctx)
	case menu.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldHidden:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case menu.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldLevel:
		return m.AddedLevel()
	case menu.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldURL) {
		fields = append(fields, menu.FieldURL)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldHidden) {
		fields = append(fields, menu.FieldHidden)
	}
	if m.FieldCleared(menu.FieldDesc) {
		fields = append(fields, menu.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldURL:
		m.ClearURL()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldHidden:
		m.ClearHidden()
		return nil
	case menu.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldURL:
		m.ResetURL()
		return nil
	case menu.FieldLevel:
		m.ResetLevel()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldHidden:
		m.ResetHidden()
		return nil
	case menu.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	user_id          *int
	adduser_id       *int
	sn               *string
	source           *order.Source
	status           *order.Status
	integration      *int
	addintegration   *int
	payment_time     *time.Time
	note             *string
	comment_time     *time.Time
	delete           *order.Delete
	clearedFields    map[string]struct{}
	items            map[int]struct{}
	removeditems     map[int]struct{}
	cleareditems     bool
	amounts          map[int]struct{}
	removedamounts   map[int]struct{}
	clearedamounts   bool
	pays             map[int]struct{}
	removedpays      map[int]struct{}
	clearedpays      bool
	deliverys        map[int]struct{}
	removeddeliverys map[int]struct{}
	cleareddeliverys bool
	done             bool
	oldValue         func(context.Context) (*Order, error)
	predicates       []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[order.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, order.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[order.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, order.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetSn sets the "sn" field.
func (m *OrderMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *OrderMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *OrderMutation) ResetSn() {
	m.sn = nil
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(o order.Source) {
	m.source = &o
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r order.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v order.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *OrderMutation) ClearSource() {
	m.source = nil
	m.clearedFields[order.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *OrderMutation) SourceCleared() bool {
	_, ok := m.clearedFields[order.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, order.FieldSource)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetIntegration sets the "integration" field.
func (m *OrderMutation) SetIntegration(i int) {
	m.integration = &i
	m.addintegration = nil
}

// Integration returns the value of the "integration" field in the mutation.
func (m *OrderMutation) Integration() (r int, exists bool) {
	v := m.integration
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegration returns the old "integration" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIntegration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntegration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntegration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegration: %w", err)
	}
	return oldValue.Integration, nil
}

// AddIntegration adds i to the "integration" field.
func (m *OrderMutation) AddIntegration(i int) {
	if m.addintegration != nil {
		*m.addintegration += i
	} else {
		m.addintegration = &i
	}
}

// AddedIntegration returns the value that was added to the "integration" field in this mutation.
func (m *OrderMutation) AddedIntegration() (r int, exists bool) {
	v := m.addintegration
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntegration resets all changes to the "integration" field.
func (m *OrderMutation) ResetIntegration() {
	m.integration = nil
	m.addintegration = nil
}

// SetPaymentTime sets the "payment_time" field.
func (m *OrderMutation) SetPaymentTime(t time.Time) {
	m.payment_time = &t
}

// PaymentTime returns the value of the "payment_time" field in the mutation.
func (m *OrderMutation) PaymentTime() (r time.Time, exists bool) {
	v := m.payment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentTime returns the old "payment_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentTime: %w", err)
	}
	return oldValue.PaymentTime, nil
}

// ClearPaymentTime clears the value of the "payment_time" field.
func (m *OrderMutation) ClearPaymentTime() {
	m.payment_time = nil
	m.clearedFields[order.FieldPaymentTime] = struct{}{}
}

// PaymentTimeCleared returns if the "payment_time" field was cleared in this mutation.
func (m *OrderMutation) PaymentTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldPaymentTime]
	return ok
}

// ResetPaymentTime resets all changes to the "payment_time" field.
func (m *OrderMutation) ResetPaymentTime() {
	m.payment_time = nil
	delete(m.clearedFields, order.FieldPaymentTime)
}

// SetNote sets the "note" field.
func (m *OrderMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *OrderMutation) ResetNote() {
	m.note = nil
}

// SetCommentTime sets the "comment_time" field.
func (m *OrderMutation) SetCommentTime(t time.Time) {
	m.comment_time = &t
}

// CommentTime returns the value of the "comment_time" field in the mutation.
func (m *OrderMutation) CommentTime() (r time.Time, exists bool) {
	v := m.comment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentTime returns the old "comment_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCommentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentTime: %w", err)
	}
	return oldValue.CommentTime, nil
}

// ClearCommentTime clears the value of the "comment_time" field.
func (m *OrderMutation) ClearCommentTime() {
	m.comment_time = nil
	m.clearedFields[order.FieldCommentTime] = struct{}{}
}

// CommentTimeCleared returns if the "comment_time" field was cleared in this mutation.
func (m *OrderMutation) CommentTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldCommentTime]
	return ok
}

// ResetCommentTime resets all changes to the "comment_time" field.
func (m *OrderMutation) ResetCommentTime() {
	m.comment_time = nil
	delete(m.clearedFields, order.FieldCommentTime)
}

// SetDelete sets the "delete" field.
func (m *OrderMutation) SetDelete(o order.Delete) {
	m.delete = &o
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderMutation) Delete() (r order.Delete, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDelete(ctx context.Context) (v order.Delete, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderMutation) ClearDelete() {
	m.delete = nil
	m.clearedFields[order.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[order.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderMutation) ResetDelete() {
	m.delete = nil
	delete(m.clearedFields, order.FieldDelete)
}

// AddItemIDs adds the "items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the OrderItem entity.
func (m *OrderMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *OrderMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *OrderMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddAmountIDs adds the "amounts" edge to the OrderAmounts entity by ids.
func (m *OrderMutation) AddAmountIDs(ids ...int) {
	if m.amounts == nil {
		m.amounts = make(map[int]struct{})
	}
	for i := range ids {
		m.amounts[ids[i]] = struct{}{}
	}
}

// ClearAmounts clears the "amounts" edge to the OrderAmounts entity.
func (m *OrderMutation) ClearAmounts() {
	m.clearedamounts = true
}

// AmountsCleared reports if the "amounts" edge to the OrderAmounts entity was cleared.
func (m *OrderMutation) AmountsCleared() bool {
	return m.clearedamounts
}

// RemoveAmountIDs removes the "amounts" edge to the OrderAmounts entity by IDs.
func (m *OrderMutation) RemoveAmountIDs(ids ...int) {
	if m.removedamounts == nil {
		m.removedamounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.amounts, ids[i])
		m.removedamounts[ids[i]] = struct{}{}
	}
}

// RemovedAmounts returns the removed IDs of the "amounts" edge to the OrderAmounts entity.
func (m *OrderMutation) RemovedAmountsIDs() (ids []int) {
	for id := range m.removedamounts {
		ids = append(ids, id)
	}
	return
}

// AmountsIDs returns the "amounts" edge IDs in the mutation.
func (m *OrderMutation) AmountsIDs() (ids []int) {
	for id := range m.amounts {
		ids = append(ids, id)
	}
	return
}

// ResetAmounts resets all changes to the "amounts" edge.
func (m *OrderMutation) ResetAmounts() {
	m.amounts = nil
	m.clearedamounts = false
	m.removedamounts = nil
}

// AddPayIDs adds the "pays" edge to the OrderPay entity by ids.
func (m *OrderMutation) AddPayIDs(ids ...int) {
	if m.pays == nil {
		m.pays = make(map[int]struct{})
	}
	for i := range ids {
		m.pays[ids[i]] = struct{}{}
	}
}

// ClearPays clears the "pays" edge to the OrderPay entity.
func (m *OrderMutation) ClearPays() {
	m.clearedpays = true
}

// PaysCleared reports if the "pays" edge to the OrderPay entity was cleared.
func (m *OrderMutation) PaysCleared() bool {
	return m.clearedpays
}

// RemovePayIDs removes the "pays" edge to the OrderPay entity by IDs.
func (m *OrderMutation) RemovePayIDs(ids ...int) {
	if m.removedpays == nil {
		m.removedpays = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pays, ids[i])
		m.removedpays[ids[i]] = struct{}{}
	}
}

// RemovedPays returns the removed IDs of the "pays" edge to the OrderPay entity.
func (m *OrderMutation) RemovedPaysIDs() (ids []int) {
	for id := range m.removedpays {
		ids = append(ids, id)
	}
	return
}

// PaysIDs returns the "pays" edge IDs in the mutation.
func (m *OrderMutation) PaysIDs() (ids []int) {
	for id := range m.pays {
		ids = append(ids, id)
	}
	return
}

// ResetPays resets all changes to the "pays" edge.
func (m *OrderMutation) ResetPays() {
	m.pays = nil
	m.clearedpays = false
	m.removedpays = nil
}

// AddDeliveryIDs adds the "deliverys" edge to the OrderDelivery entity by ids.
func (m *OrderMutation) AddDeliveryIDs(ids ...int) {
	if m.deliverys == nil {
		m.deliverys = make(map[int]struct{})
	}
	for i := range ids {
		m.deliverys[ids[i]] = struct{}{}
	}
}

// ClearDeliverys clears the "deliverys" edge to the OrderDelivery entity.
func (m *OrderMutation) ClearDeliverys() {
	m.cleareddeliverys = true
}

// DeliverysCleared reports if the "deliverys" edge to the OrderDelivery entity was cleared.
func (m *OrderMutation) DeliverysCleared() bool {
	return m.cleareddeliverys
}

// RemoveDeliveryIDs removes the "deliverys" edge to the OrderDelivery entity by IDs.
func (m *OrderMutation) RemoveDeliveryIDs(ids ...int) {
	if m.removeddeliverys == nil {
		m.removeddeliverys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deliverys, ids[i])
		m.removeddeliverys[ids[i]] = struct{}{}
	}
}

// RemovedDeliverys returns the removed IDs of the "deliverys" edge to the OrderDelivery entity.
func (m *OrderMutation) RemovedDeliverysIDs() (ids []int) {
	for id := range m.removeddeliverys {
		ids = append(ids, id)
	}
	return
}

// DeliverysIDs returns the "deliverys" edge IDs in the mutation.
func (m *OrderMutation) DeliverysIDs() (ids []int) {
	for id := range m.deliverys {
		ids = append(ids, id)
	}
	return
}

// ResetDeliverys resets all changes to the "deliverys" edge.
func (m *OrderMutation) ResetDeliverys() {
	m.deliverys = nil
	m.cleareddeliverys = false
	m.removeddeliverys = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.sn != nil {
		fields = append(fields, order.FieldSn)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.integration != nil {
		fields = append(fields, order.FieldIntegration)
	}
	if m.payment_time != nil {
		fields = append(fields, order.FieldPaymentTime)
	}
	if m.note != nil {
		fields = append(fields, order.FieldNote)
	}
	if m.comment_time != nil {
		fields = append(fields, order.FieldCommentTime)
	}
	if m.delete != nil {
		fields = append(fields, order.FieldDelete)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldSn:
		return m.Sn()
	case order.FieldSource:
		return m.Source()
	case order.FieldStatus:
		return m.Status()
	case order.FieldIntegration:
		return m.Integration()
	case order.FieldPaymentTime:
		return m.PaymentTime()
	case order.FieldNote:
		return m.Note()
	case order.FieldCommentTime:
		return m.CommentTime()
	case order.FieldDelete:
		return m.Delete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldSn:
		return m.OldSn(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldIntegration:
		return m.OldIntegration(ctx)
	case order.FieldPaymentTime:
		return m.OldPaymentTime(ctx)
	case order.FieldNote:
		return m.OldNote(ctx)
	case order.FieldCommentTime:
		return m.OldCommentTime(ctx)
	case order.FieldDelete:
		return m.OldDelete(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case order.FieldSource:
		v, ok := value.(order.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldIntegration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegration(v)
		return nil
	case order.FieldPaymentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentTime(v)
		return nil
	case order.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case order.FieldCommentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentTime(v)
		return nil
	case order.FieldDelete:
		v, ok := value.(order.Delete)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.addintegration != nil {
		fields = append(fields, order.FieldIntegration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldUserID:
		return m.AddedUserID()
	case order.FieldIntegration:
		return m.AddedIntegration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case order.FieldIntegration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntegration(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldCreatedAt) {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.FieldCleared(order.FieldUpdatedAt) {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.FieldCleared(order.FieldSource) {
		fields = append(fields, order.FieldSource)
	}
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldPaymentTime) {
		fields = append(fields, order.FieldPaymentTime)
	}
	if m.FieldCleared(order.FieldCommentTime) {
		fields = append(fields, order.FieldCommentTime)
	}
	if m.FieldCleared(order.FieldDelete) {
		fields = append(fields, order.FieldDelete)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case order.FieldSource:
		m.ClearSource()
		return nil
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldPaymentTime:
		m.ClearPaymentTime()
		return nil
	case order.FieldCommentTime:
		m.ClearCommentTime()
		return nil
	case order.FieldDelete:
		m.ClearDelete()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldSn:
		m.ResetSn()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldIntegration:
		m.ResetIntegration()
		return nil
	case order.FieldPaymentTime:
		m.ResetPaymentTime()
		return nil
	case order.FieldNote:
		m.ResetNote()
		return nil
	case order.FieldCommentTime:
		m.ResetCommentTime()
		return nil
	case order.FieldDelete:
		m.ResetDelete()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.items != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.amounts != nil {
		edges = append(edges, order.EdgeAmounts)
	}
	if m.pays != nil {
		edges = append(edges, order.EdgePays)
	}
	if m.deliverys != nil {
		edges = append(edges, order.EdgeDeliverys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeAmounts:
		ids := make([]ent.Value, 0, len(m.amounts))
		for id := range m.amounts {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePays:
		ids := make([]ent.Value, 0, len(m.pays))
		for id := range m.pays {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeDeliverys:
		ids := make([]ent.Value, 0, len(m.deliverys))
		for id := range m.deliverys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeditems != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.removedamounts != nil {
		edges = append(edges, order.EdgeAmounts)
	}
	if m.removedpays != nil {
		edges = append(edges, order.EdgePays)
	}
	if m.removeddeliverys != nil {
		edges = append(edges, order.EdgeDeliverys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeAmounts:
		ids := make([]ent.Value, 0, len(m.removedamounts))
		for id := range m.removedamounts {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePays:
		ids := make([]ent.Value, 0, len(m.removedpays))
		for id := range m.removedpays {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeDeliverys:
		ids := make([]ent.Value, 0, len(m.removeddeliverys))
		for id := range m.removeddeliverys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareditems {
		edges = append(edges, order.EdgeItems)
	}
	if m.clearedamounts {
		edges = append(edges, order.EdgeAmounts)
	}
	if m.clearedpays {
		edges = append(edges, order.EdgePays)
	}
	if m.cleareddeliverys {
		edges = append(edges, order.EdgeDeliverys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeItems:
		return m.cleareditems
	case order.EdgeAmounts:
		return m.clearedamounts
	case order.EdgePays:
		return m.clearedpays
	case order.EdgeDeliverys:
		return m.cleareddeliverys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeItems:
		m.ResetItems()
		return nil
	case order.EdgeAmounts:
		m.ResetAmounts()
		return nil
	case order.EdgePays:
		m.ResetPays()
		return nil
	case order.EdgeDeliverys:
		m.ResetDeliverys()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAmountsMutation represents an operation that mutates the OrderAmounts nodes in the graph.
type OrderAmountsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	total_amount          *float64
	addtotal_amount       *float64
	pay_amount            *float64
	addpay_amount         *float64
	freight_amount        *float64
	addfreight_amount     *float64
	promotion_amount      *float64
	addpromotion_amount   *float64
	integration_amount    *float64
	addintegration_amount *float64
	coupon_id             *int
	addcoupon_id          *int
	coupon_amount         *float64
	addcoupon_amount      *float64
	discount_amount       *float64
	adddiscount_amount    *float64
	clearedFields         map[string]struct{}
	_order                *int
	cleared_order         bool
	done                  bool
	oldValue              func(context.Context) (*OrderAmounts, error)
	predicates            []predicate.OrderAmounts
}

var _ ent.Mutation = (*OrderAmountsMutation)(nil)

// orderamountsOption allows management of the mutation configuration using functional options.
type orderamountsOption func(*OrderAmountsMutation)

// newOrderAmountsMutation creates new mutation for the OrderAmounts entity.
func newOrderAmountsMutation(c config, op Op, opts ...orderamountsOption) *OrderAmountsMutation {
	m := &OrderAmountsMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAmounts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAmountsID sets the ID field of the mutation.
func withOrderAmountsID(id int) orderamountsOption {
	return func(m *OrderAmountsMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAmounts
		)
		m.oldValue = func(ctx context.Context) (*OrderAmounts, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAmounts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAmounts sets the old OrderAmounts of the mutation.
func withOrderAmounts(node *OrderAmounts) orderamountsOption {
	return func(m *OrderAmountsMutation) {
		m.oldValue = func(context.Context) (*OrderAmounts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAmountsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAmountsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAmountsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAmountsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAmountsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderAmountsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderamounts.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderAmountsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderamounts.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAmountsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderamounts.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAmountsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAmountsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderAmountsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderamounts.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderAmountsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderamounts.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAmountsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderamounts.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderAmountsMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAmountsMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderAmountsMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderamounts.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderAmountsMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderamounts.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAmountsMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderamounts.FieldOrderID)
}

// SetTotalAmount sets the "total_amount" field.
func (m *OrderAmountsMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *OrderAmountsMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *OrderAmountsMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *OrderAmountsMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetPayAmount sets the "pay_amount" field.
func (m *OrderAmountsMutation) SetPayAmount(f float64) {
	m.pay_amount = &f
	m.addpay_amount = nil
}

// PayAmount returns the value of the "pay_amount" field in the mutation.
func (m *OrderAmountsMutation) PayAmount() (r float64, exists bool) {
	v := m.pay_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAmount returns the old "pay_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldPayAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAmount: %w", err)
	}
	return oldValue.PayAmount, nil
}

// AddPayAmount adds f to the "pay_amount" field.
func (m *OrderAmountsMutation) AddPayAmount(f float64) {
	if m.addpay_amount != nil {
		*m.addpay_amount += f
	} else {
		m.addpay_amount = &f
	}
}

// AddedPayAmount returns the value that was added to the "pay_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedPayAmount() (r float64, exists bool) {
	v := m.addpay_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayAmount resets all changes to the "pay_amount" field.
func (m *OrderAmountsMutation) ResetPayAmount() {
	m.pay_amount = nil
	m.addpay_amount = nil
}

// SetFreightAmount sets the "freight_amount" field.
func (m *OrderAmountsMutation) SetFreightAmount(f float64) {
	m.freight_amount = &f
	m.addfreight_amount = nil
}

// FreightAmount returns the value of the "freight_amount" field in the mutation.
func (m *OrderAmountsMutation) FreightAmount() (r float64, exists bool) {
	v := m.freight_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFreightAmount returns the old "freight_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldFreightAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFreightAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFreightAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreightAmount: %w", err)
	}
	return oldValue.FreightAmount, nil
}

// AddFreightAmount adds f to the "freight_amount" field.
func (m *OrderAmountsMutation) AddFreightAmount(f float64) {
	if m.addfreight_amount != nil {
		*m.addfreight_amount += f
	} else {
		m.addfreight_amount = &f
	}
}

// AddedFreightAmount returns the value that was added to the "freight_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedFreightAmount() (r float64, exists bool) {
	v := m.addfreight_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreightAmount resets all changes to the "freight_amount" field.
func (m *OrderAmountsMutation) ResetFreightAmount() {
	m.freight_amount = nil
	m.addfreight_amount = nil
}

// SetPromotionAmount sets the "promotion_amount" field.
func (m *OrderAmountsMutation) SetPromotionAmount(f float64) {
	m.promotion_amount = &f
	m.addpromotion_amount = nil
}

// PromotionAmount returns the value of the "promotion_amount" field in the mutation.
func (m *OrderAmountsMutation) PromotionAmount() (r float64, exists bool) {
	v := m.promotion_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionAmount returns the old "promotion_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldPromotionAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPromotionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPromotionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionAmount: %w", err)
	}
	return oldValue.PromotionAmount, nil
}

// AddPromotionAmount adds f to the "promotion_amount" field.
func (m *OrderAmountsMutation) AddPromotionAmount(f float64) {
	if m.addpromotion_amount != nil {
		*m.addpromotion_amount += f
	} else {
		m.addpromotion_amount = &f
	}
}

// AddedPromotionAmount returns the value that was added to the "promotion_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedPromotionAmount() (r float64, exists bool) {
	v := m.addpromotion_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromotionAmount resets all changes to the "promotion_amount" field.
func (m *OrderAmountsMutation) ResetPromotionAmount() {
	m.promotion_amount = nil
	m.addpromotion_amount = nil
}

// SetIntegrationAmount sets the "integration_amount" field.
func (m *OrderAmountsMutation) SetIntegrationAmount(f float64) {
	m.integration_amount = &f
	m.addintegration_amount = nil
}

// IntegrationAmount returns the value of the "integration_amount" field in the mutation.
func (m *OrderAmountsMutation) IntegrationAmount() (r float64, exists bool) {
	v := m.integration_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationAmount returns the old "integration_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldIntegrationAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntegrationAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntegrationAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationAmount: %w", err)
	}
	return oldValue.IntegrationAmount, nil
}

// AddIntegrationAmount adds f to the "integration_amount" field.
func (m *OrderAmountsMutation) AddIntegrationAmount(f float64) {
	if m.addintegration_amount != nil {
		*m.addintegration_amount += f
	} else {
		m.addintegration_amount = &f
	}
}

// AddedIntegrationAmount returns the value that was added to the "integration_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedIntegrationAmount() (r float64, exists bool) {
	v := m.addintegration_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntegrationAmount resets all changes to the "integration_amount" field.
func (m *OrderAmountsMutation) ResetIntegrationAmount() {
	m.integration_amount = nil
	m.addintegration_amount = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *OrderAmountsMutation) SetCouponID(i int) {
	m.coupon_id = &i
	m.addcoupon_id = nil
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *OrderAmountsMutation) CouponID() (r int, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldCouponID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// AddCouponID adds i to the "coupon_id" field.
func (m *OrderAmountsMutation) AddCouponID(i int) {
	if m.addcoupon_id != nil {
		*m.addcoupon_id += i
	} else {
		m.addcoupon_id = &i
	}
}

// AddedCouponID returns the value that was added to the "coupon_id" field in this mutation.
func (m *OrderAmountsMutation) AddedCouponID() (r int, exists bool) {
	v := m.addcoupon_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *OrderAmountsMutation) ClearCouponID() {
	m.coupon_id = nil
	m.addcoupon_id = nil
	m.clearedFields[orderamounts.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *OrderAmountsMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[orderamounts.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *OrderAmountsMutation) ResetCouponID() {
	m.coupon_id = nil
	m.addcoupon_id = nil
	delete(m.clearedFields, orderamounts.FieldCouponID)
}

// SetCouponAmount sets the "coupon_amount" field.
func (m *OrderAmountsMutation) SetCouponAmount(f float64) {
	m.coupon_amount = &f
	m.addcoupon_amount = nil
}

// CouponAmount returns the value of the "coupon_amount" field in the mutation.
func (m *OrderAmountsMutation) CouponAmount() (r float64, exists bool) {
	v := m.coupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponAmount returns the old "coupon_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldCouponAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCouponAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCouponAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponAmount: %w", err)
	}
	return oldValue.CouponAmount, nil
}

// AddCouponAmount adds f to the "coupon_amount" field.
func (m *OrderAmountsMutation) AddCouponAmount(f float64) {
	if m.addcoupon_amount != nil {
		*m.addcoupon_amount += f
	} else {
		m.addcoupon_amount = &f
	}
}

// AddedCouponAmount returns the value that was added to the "coupon_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedCouponAmount() (r float64, exists bool) {
	v := m.addcoupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponAmount resets all changes to the "coupon_amount" field.
func (m *OrderAmountsMutation) ResetCouponAmount() {
	m.coupon_amount = nil
	m.addcoupon_amount = nil
}

// SetDiscountAmount sets the "discount_amount" field.
func (m *OrderAmountsMutation) SetDiscountAmount(f float64) {
	m.discount_amount = &f
	m.adddiscount_amount = nil
}

// DiscountAmount returns the value of the "discount_amount" field in the mutation.
func (m *OrderAmountsMutation) DiscountAmount() (r float64, exists bool) {
	v := m.discount_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountAmount returns the old "discount_amount" field's value of the OrderAmounts entity.
// If the OrderAmounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountsMutation) OldDiscountAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscountAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscountAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountAmount: %w", err)
	}
	return oldValue.DiscountAmount, nil
}

// AddDiscountAmount adds f to the "discount_amount" field.
func (m *OrderAmountsMutation) AddDiscountAmount(f float64) {
	if m.adddiscount_amount != nil {
		*m.adddiscount_amount += f
	} else {
		m.adddiscount_amount = &f
	}
}

// AddedDiscountAmount returns the value that was added to the "discount_amount" field in this mutation.
func (m *OrderAmountsMutation) AddedDiscountAmount() (r float64, exists bool) {
	v := m.adddiscount_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountAmount resets all changes to the "discount_amount" field.
func (m *OrderAmountsMutation) ResetDiscountAmount() {
	m.discount_amount = nil
	m.adddiscount_amount = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderAmountsMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderAmountsMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderAmountsMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderAmountsMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderAmountsMutation builder.
func (m *OrderAmountsMutation) Where(ps ...predicate.OrderAmounts) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderAmountsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderAmounts).
func (m *OrderAmountsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAmountsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, orderamounts.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderamounts.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderamounts.FieldOrderID)
	}
	if m.total_amount != nil {
		fields = append(fields, orderamounts.FieldTotalAmount)
	}
	if m.pay_amount != nil {
		fields = append(fields, orderamounts.FieldPayAmount)
	}
	if m.freight_amount != nil {
		fields = append(fields, orderamounts.FieldFreightAmount)
	}
	if m.promotion_amount != nil {
		fields = append(fields, orderamounts.FieldPromotionAmount)
	}
	if m.integration_amount != nil {
		fields = append(fields, orderamounts.FieldIntegrationAmount)
	}
	if m.coupon_id != nil {
		fields = append(fields, orderamounts.FieldCouponID)
	}
	if m.coupon_amount != nil {
		fields = append(fields, orderamounts.FieldCouponAmount)
	}
	if m.discount_amount != nil {
		fields = append(fields, orderamounts.FieldDiscountAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAmountsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderamounts.FieldCreatedAt:
		return m.CreatedAt()
	case orderamounts.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderamounts.FieldOrderID:
		return m.OrderID()
	case orderamounts.FieldTotalAmount:
		return m.TotalAmount()
	case orderamounts.FieldPayAmount:
		return m.PayAmount()
	case orderamounts.FieldFreightAmount:
		return m.FreightAmount()
	case orderamounts.FieldPromotionAmount:
		return m.PromotionAmount()
	case orderamounts.FieldIntegrationAmount:
		return m.IntegrationAmount()
	case orderamounts.FieldCouponID:
		return m.CouponID()
	case orderamounts.FieldCouponAmount:
		return m.CouponAmount()
	case orderamounts.FieldDiscountAmount:
		return m.DiscountAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAmountsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderamounts.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderamounts.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderamounts.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderamounts.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case orderamounts.FieldPayAmount:
		return m.OldPayAmount(ctx)
	case orderamounts.FieldFreightAmount:
		return m.OldFreightAmount(ctx)
	case orderamounts.FieldPromotionAmount:
		return m.OldPromotionAmount(ctx)
	case orderamounts.FieldIntegrationAmount:
		return m.OldIntegrationAmount(ctx)
	case orderamounts.FieldCouponID:
		return m.OldCouponID(ctx)
	case orderamounts.FieldCouponAmount:
		return m.OldCouponAmount(ctx)
	case orderamounts.FieldDiscountAmount:
		return m.OldDiscountAmount(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAmounts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderamounts.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderamounts.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderamounts.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderamounts.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case orderamounts.FieldPayAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAmount(v)
		return nil
	case orderamounts.FieldFreightAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreightAmount(v)
		return nil
	case orderamounts.FieldPromotionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionAmount(v)
		return nil
	case orderamounts.FieldIntegrationAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationAmount(v)
		return nil
	case orderamounts.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case orderamounts.FieldCouponAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponAmount(v)
		return nil
	case orderamounts.FieldDiscountAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAmountsMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, orderamounts.FieldTotalAmount)
	}
	if m.addpay_amount != nil {
		fields = append(fields, orderamounts.FieldPayAmount)
	}
	if m.addfreight_amount != nil {
		fields = append(fields, orderamounts.FieldFreightAmount)
	}
	if m.addpromotion_amount != nil {
		fields = append(fields, orderamounts.FieldPromotionAmount)
	}
	if m.addintegration_amount != nil {
		fields = append(fields, orderamounts.FieldIntegrationAmount)
	}
	if m.addcoupon_id != nil {
		fields = append(fields, orderamounts.FieldCouponID)
	}
	if m.addcoupon_amount != nil {
		fields = append(fields, orderamounts.FieldCouponAmount)
	}
	if m.adddiscount_amount != nil {
		fields = append(fields, orderamounts.FieldDiscountAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAmountsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderamounts.FieldTotalAmount:
		return m.AddedTotalAmount()
	case orderamounts.FieldPayAmount:
		return m.AddedPayAmount()
	case orderamounts.FieldFreightAmount:
		return m.AddedFreightAmount()
	case orderamounts.FieldPromotionAmount:
		return m.AddedPromotionAmount()
	case orderamounts.FieldIntegrationAmount:
		return m.AddedIntegrationAmount()
	case orderamounts.FieldCouponID:
		return m.AddedCouponID()
	case orderamounts.FieldCouponAmount:
		return m.AddedCouponAmount()
	case orderamounts.FieldDiscountAmount:
		return m.AddedDiscountAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderamounts.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case orderamounts.FieldPayAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayAmount(v)
		return nil
	case orderamounts.FieldFreightAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreightAmount(v)
		return nil
	case orderamounts.FieldPromotionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromotionAmount(v)
		return nil
	case orderamounts.FieldIntegrationAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntegrationAmount(v)
		return nil
	case orderamounts.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponID(v)
		return nil
	case orderamounts.FieldCouponAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponAmount(v)
		return nil
	case orderamounts.FieldDiscountAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAmountsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderamounts.FieldCreatedAt) {
		fields = append(fields, orderamounts.FieldCreatedAt)
	}
	if m.FieldCleared(orderamounts.FieldUpdatedAt) {
		fields = append(fields, orderamounts.FieldUpdatedAt)
	}
	if m.FieldCleared(orderamounts.FieldOrderID) {
		fields = append(fields, orderamounts.FieldOrderID)
	}
	if m.FieldCleared(orderamounts.FieldCouponID) {
		fields = append(fields, orderamounts.FieldCouponID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAmountsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAmountsMutation) ClearField(name string) error {
	switch name {
	case orderamounts.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderamounts.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderamounts.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderamounts.FieldCouponID:
		m.ClearCouponID()
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAmountsMutation) ResetField(name string) error {
	switch name {
	case orderamounts.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderamounts.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderamounts.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderamounts.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case orderamounts.FieldPayAmount:
		m.ResetPayAmount()
		return nil
	case orderamounts.FieldFreightAmount:
		m.ResetFreightAmount()
		return nil
	case orderamounts.FieldPromotionAmount:
		m.ResetPromotionAmount()
		return nil
	case orderamounts.FieldIntegrationAmount:
		m.ResetIntegrationAmount()
		return nil
	case orderamounts.FieldCouponID:
		m.ResetCouponID()
		return nil
	case orderamounts.FieldCouponAmount:
		m.ResetCouponAmount()
		return nil
	case orderamounts.FieldDiscountAmount:
		m.ResetDiscountAmount()
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAmountsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderamounts.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAmountsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderamounts.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAmountsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAmountsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAmountsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderamounts.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAmountsMutation) EdgeCleared(name string) bool {
	switch name {
	case orderamounts.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAmountsMutation) ClearEdge(name string) error {
	switch name {
	case orderamounts.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAmountsMutation) ResetEdge(name string) error {
	switch name {
	case orderamounts.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmounts edge %s", name)
}

// OrderDeliveryMutation represents an operation that mutates the OrderDelivery nodes in the graph.
type OrderDeliveryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	sn                      *string
	delivery_company        *string
	delivery_time           *time.Time
	receiver_name           *string
	receiver_phone          *string
	receiver_post_code      *string
	receiver_province       *string
	receiver_city           *string
	receiver_region         *string
	receiver_detail_address *string
	receive_time            *time.Time
	clearedFields           map[string]struct{}
	_order                  *int
	cleared_order           bool
	done                    bool
	oldValue                func(context.Context) (*OrderDelivery, error)
	predicates              []predicate.OrderDelivery
}

var _ ent.Mutation = (*OrderDeliveryMutation)(nil)

// orderdeliveryOption allows management of the mutation configuration using functional options.
type orderdeliveryOption func(*OrderDeliveryMutation)

// newOrderDeliveryMutation creates new mutation for the OrderDelivery entity.
func newOrderDeliveryMutation(c config, op Op, opts ...orderdeliveryOption) *OrderDeliveryMutation {
	m := &OrderDeliveryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderDelivery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderDeliveryID sets the ID field of the mutation.
func withOrderDeliveryID(id int) orderdeliveryOption {
	return func(m *OrderDeliveryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderDelivery
		)
		m.oldValue = func(ctx context.Context) (*OrderDelivery, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderDelivery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderDelivery sets the old OrderDelivery of the mutation.
func withOrderDelivery(node *OrderDelivery) orderdeliveryOption {
	return func(m *OrderDeliveryMutation) {
		m.oldValue = func(context.Context) (*OrderDelivery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderDeliveryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderDeliveryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderDeliveryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderDeliveryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderDeliveryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderDeliveryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderdelivery.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderDeliveryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderDeliveryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderdelivery.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderDeliveryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderDeliveryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderDeliveryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderdelivery.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderDeliveryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderDeliveryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderdelivery.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderDeliveryMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderDeliveryMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderDeliveryMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderdelivery.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderDeliveryMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderDeliveryMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderdelivery.FieldOrderID)
}

// SetSn sets the "sn" field.
func (m *OrderDeliveryMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *OrderDeliveryMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *OrderDeliveryMutation) ResetSn() {
	m.sn = nil
}

// SetDeliveryCompany sets the "delivery_company" field.
func (m *OrderDeliveryMutation) SetDeliveryCompany(s string) {
	m.delivery_company = &s
}

// DeliveryCompany returns the value of the "delivery_company" field in the mutation.
func (m *OrderDeliveryMutation) DeliveryCompany() (r string, exists bool) {
	v := m.delivery_company
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryCompany returns the old "delivery_company" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldDeliveryCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeliveryCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeliveryCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryCompany: %w", err)
	}
	return oldValue.DeliveryCompany, nil
}

// ClearDeliveryCompany clears the value of the "delivery_company" field.
func (m *OrderDeliveryMutation) ClearDeliveryCompany() {
	m.delivery_company = nil
	m.clearedFields[orderdelivery.FieldDeliveryCompany] = struct{}{}
}

// DeliveryCompanyCleared returns if the "delivery_company" field was cleared in this mutation.
func (m *OrderDeliveryMutation) DeliveryCompanyCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldDeliveryCompany]
	return ok
}

// ResetDeliveryCompany resets all changes to the "delivery_company" field.
func (m *OrderDeliveryMutation) ResetDeliveryCompany() {
	m.delivery_company = nil
	delete(m.clearedFields, orderdelivery.FieldDeliveryCompany)
}

// SetDeliveryTime sets the "delivery_time" field.
func (m *OrderDeliveryMutation) SetDeliveryTime(t time.Time) {
	m.delivery_time = &t
}

// DeliveryTime returns the value of the "delivery_time" field in the mutation.
func (m *OrderDeliveryMutation) DeliveryTime() (r time.Time, exists bool) {
	v := m.delivery_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryTime returns the old "delivery_time" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldDeliveryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeliveryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeliveryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryTime: %w", err)
	}
	return oldValue.DeliveryTime, nil
}

// ClearDeliveryTime clears the value of the "delivery_time" field.
func (m *OrderDeliveryMutation) ClearDeliveryTime() {
	m.delivery_time = nil
	m.clearedFields[orderdelivery.FieldDeliveryTime] = struct{}{}
}

// DeliveryTimeCleared returns if the "delivery_time" field was cleared in this mutation.
func (m *OrderDeliveryMutation) DeliveryTimeCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldDeliveryTime]
	return ok
}

// ResetDeliveryTime resets all changes to the "delivery_time" field.
func (m *OrderDeliveryMutation) ResetDeliveryTime() {
	m.delivery_time = nil
	delete(m.clearedFields, orderdelivery.FieldDeliveryTime)
}

// SetReceiverName sets the "receiver_name" field.
func (m *OrderDeliveryMutation) SetReceiverName(s string) {
	m.receiver_name = &s
}

// ReceiverName returns the value of the "receiver_name" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverName() (r string, exists bool) {
	v := m.receiver_name
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverName returns the old "receiver_name" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverName: %w", err)
	}
	return oldValue.ReceiverName, nil
}

// ClearReceiverName clears the value of the "receiver_name" field.
func (m *OrderDeliveryMutation) ClearReceiverName() {
	m.receiver_name = nil
	m.clearedFields[orderdelivery.FieldReceiverName] = struct{}{}
}

// ReceiverNameCleared returns if the "receiver_name" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverNameCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverName]
	return ok
}

// ResetReceiverName resets all changes to the "receiver_name" field.
func (m *OrderDeliveryMutation) ResetReceiverName() {
	m.receiver_name = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverName)
}

// SetReceiverPhone sets the "receiver_phone" field.
func (m *OrderDeliveryMutation) SetReceiverPhone(s string) {
	m.receiver_phone = &s
}

// ReceiverPhone returns the value of the "receiver_phone" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverPhone() (r string, exists bool) {
	v := m.receiver_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverPhone returns the old "receiver_phone" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverPhone: %w", err)
	}
	return oldValue.ReceiverPhone, nil
}

// ClearReceiverPhone clears the value of the "receiver_phone" field.
func (m *OrderDeliveryMutation) ClearReceiverPhone() {
	m.receiver_phone = nil
	m.clearedFields[orderdelivery.FieldReceiverPhone] = struct{}{}
}

// ReceiverPhoneCleared returns if the "receiver_phone" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverPhoneCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverPhone]
	return ok
}

// ResetReceiverPhone resets all changes to the "receiver_phone" field.
func (m *OrderDeliveryMutation) ResetReceiverPhone() {
	m.receiver_phone = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverPhone)
}

// SetReceiverPostCode sets the "receiver_post_code" field.
func (m *OrderDeliveryMutation) SetReceiverPostCode(s string) {
	m.receiver_post_code = &s
}

// ReceiverPostCode returns the value of the "receiver_post_code" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverPostCode() (r string, exists bool) {
	v := m.receiver_post_code
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverPostCode returns the old "receiver_post_code" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverPostCode: %w", err)
	}
	return oldValue.ReceiverPostCode, nil
}

// ClearReceiverPostCode clears the value of the "receiver_post_code" field.
func (m *OrderDeliveryMutation) ClearReceiverPostCode() {
	m.receiver_post_code = nil
	m.clearedFields[orderdelivery.FieldReceiverPostCode] = struct{}{}
}

// ReceiverPostCodeCleared returns if the "receiver_post_code" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverPostCodeCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverPostCode]
	return ok
}

// ResetReceiverPostCode resets all changes to the "receiver_post_code" field.
func (m *OrderDeliveryMutation) ResetReceiverPostCode() {
	m.receiver_post_code = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverPostCode)
}

// SetReceiverProvince sets the "receiver_province" field.
func (m *OrderDeliveryMutation) SetReceiverProvince(s string) {
	m.receiver_province = &s
}

// ReceiverProvince returns the value of the "receiver_province" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverProvince() (r string, exists bool) {
	v := m.receiver_province
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverProvince returns the old "receiver_province" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverProvince: %w", err)
	}
	return oldValue.ReceiverProvince, nil
}

// ClearReceiverProvince clears the value of the "receiver_province" field.
func (m *OrderDeliveryMutation) ClearReceiverProvince() {
	m.receiver_province = nil
	m.clearedFields[orderdelivery.FieldReceiverProvince] = struct{}{}
}

// ReceiverProvinceCleared returns if the "receiver_province" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverProvinceCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverProvince]
	return ok
}

// ResetReceiverProvince resets all changes to the "receiver_province" field.
func (m *OrderDeliveryMutation) ResetReceiverProvince() {
	m.receiver_province = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverProvince)
}

// SetReceiverCity sets the "receiver_city" field.
func (m *OrderDeliveryMutation) SetReceiverCity(s string) {
	m.receiver_city = &s
}

// ReceiverCity returns the value of the "receiver_city" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverCity() (r string, exists bool) {
	v := m.receiver_city
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverCity returns the old "receiver_city" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverCity: %w", err)
	}
	return oldValue.ReceiverCity, nil
}

// ClearReceiverCity clears the value of the "receiver_city" field.
func (m *OrderDeliveryMutation) ClearReceiverCity() {
	m.receiver_city = nil
	m.clearedFields[orderdelivery.FieldReceiverCity] = struct{}{}
}

// ReceiverCityCleared returns if the "receiver_city" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverCityCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverCity]
	return ok
}

// ResetReceiverCity resets all changes to the "receiver_city" field.
func (m *OrderDeliveryMutation) ResetReceiverCity() {
	m.receiver_city = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverCity)
}

// SetReceiverRegion sets the "receiver_region" field.
func (m *OrderDeliveryMutation) SetReceiverRegion(s string) {
	m.receiver_region = &s
}

// ReceiverRegion returns the value of the "receiver_region" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverRegion() (r string, exists bool) {
	v := m.receiver_region
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverRegion returns the old "receiver_region" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverRegion: %w", err)
	}
	return oldValue.ReceiverRegion, nil
}

// ClearReceiverRegion clears the value of the "receiver_region" field.
func (m *OrderDeliveryMutation) ClearReceiverRegion() {
	m.receiver_region = nil
	m.clearedFields[orderdelivery.FieldReceiverRegion] = struct{}{}
}

// ReceiverRegionCleared returns if the "receiver_region" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverRegionCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverRegion]
	return ok
}

// ResetReceiverRegion resets all changes to the "receiver_region" field.
func (m *OrderDeliveryMutation) ResetReceiverRegion() {
	m.receiver_region = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverRegion)
}

// SetReceiverDetailAddress sets the "receiver_detail_address" field.
func (m *OrderDeliveryMutation) SetReceiverDetailAddress(s string) {
	m.receiver_detail_address = &s
}

// ReceiverDetailAddress returns the value of the "receiver_detail_address" field in the mutation.
func (m *OrderDeliveryMutation) ReceiverDetailAddress() (r string, exists bool) {
	v := m.receiver_detail_address
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverDetailAddress returns the old "receiver_detail_address" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiverDetailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverDetailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverDetailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverDetailAddress: %w", err)
	}
	return oldValue.ReceiverDetailAddress, nil
}

// ClearReceiverDetailAddress clears the value of the "receiver_detail_address" field.
func (m *OrderDeliveryMutation) ClearReceiverDetailAddress() {
	m.receiver_detail_address = nil
	m.clearedFields[orderdelivery.FieldReceiverDetailAddress] = struct{}{}
}

// ReceiverDetailAddressCleared returns if the "receiver_detail_address" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiverDetailAddressCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiverDetailAddress]
	return ok
}

// ResetReceiverDetailAddress resets all changes to the "receiver_detail_address" field.
func (m *OrderDeliveryMutation) ResetReceiverDetailAddress() {
	m.receiver_detail_address = nil
	delete(m.clearedFields, orderdelivery.FieldReceiverDetailAddress)
}

// SetReceiveTime sets the "receive_time" field.
func (m *OrderDeliveryMutation) SetReceiveTime(t time.Time) {
	m.receive_time = &t
}

// ReceiveTime returns the value of the "receive_time" field in the mutation.
func (m *OrderDeliveryMutation) ReceiveTime() (r time.Time, exists bool) {
	v := m.receive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveTime returns the old "receive_time" field's value of the OrderDelivery entity.
// If the OrderDelivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDeliveryMutation) OldReceiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveTime: %w", err)
	}
	return oldValue.ReceiveTime, nil
}

// ClearReceiveTime clears the value of the "receive_time" field.
func (m *OrderDeliveryMutation) ClearReceiveTime() {
	m.receive_time = nil
	m.clearedFields[orderdelivery.FieldReceiveTime] = struct{}{}
}

// ReceiveTimeCleared returns if the "receive_time" field was cleared in this mutation.
func (m *OrderDeliveryMutation) ReceiveTimeCleared() bool {
	_, ok := m.clearedFields[orderdelivery.FieldReceiveTime]
	return ok
}

// ResetReceiveTime resets all changes to the "receive_time" field.
func (m *OrderDeliveryMutation) ResetReceiveTime() {
	m.receive_time = nil
	delete(m.clearedFields, orderdelivery.FieldReceiveTime)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderDeliveryMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderDeliveryMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderDeliveryMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderDeliveryMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderDeliveryMutation builder.
func (m *OrderDeliveryMutation) Where(ps ...predicate.OrderDelivery) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderDeliveryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderDelivery).
func (m *OrderDeliveryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderDeliveryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, orderdelivery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderdelivery.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderdelivery.FieldOrderID)
	}
	if m.sn != nil {
		fields = append(fields, orderdelivery.FieldSn)
	}
	if m.delivery_company != nil {
		fields = append(fields, orderdelivery.FieldDeliveryCompany)
	}
	if m.delivery_time != nil {
		fields = append(fields, orderdelivery.FieldDeliveryTime)
	}
	if m.receiver_name != nil {
		fields = append(fields, orderdelivery.FieldReceiverName)
	}
	if m.receiver_phone != nil {
		fields = append(fields, orderdelivery.FieldReceiverPhone)
	}
	if m.receiver_post_code != nil {
		fields = append(fields, orderdelivery.FieldReceiverPostCode)
	}
	if m.receiver_province != nil {
		fields = append(fields, orderdelivery.FieldReceiverProvince)
	}
	if m.receiver_city != nil {
		fields = append(fields, orderdelivery.FieldReceiverCity)
	}
	if m.receiver_region != nil {
		fields = append(fields, orderdelivery.FieldReceiverRegion)
	}
	if m.receiver_detail_address != nil {
		fields = append(fields, orderdelivery.FieldReceiverDetailAddress)
	}
	if m.receive_time != nil {
		fields = append(fields, orderdelivery.FieldReceiveTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderDeliveryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderdelivery.FieldCreatedAt:
		return m.CreatedAt()
	case orderdelivery.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderdelivery.FieldOrderID:
		return m.OrderID()
	case orderdelivery.FieldSn:
		return m.Sn()
	case orderdelivery.FieldDeliveryCompany:
		return m.DeliveryCompany()
	case orderdelivery.FieldDeliveryTime:
		return m.DeliveryTime()
	case orderdelivery.FieldReceiverName:
		return m.ReceiverName()
	case orderdelivery.FieldReceiverPhone:
		return m.ReceiverPhone()
	case orderdelivery.FieldReceiverPostCode:
		return m.ReceiverPostCode()
	case orderdelivery.FieldReceiverProvince:
		return m.ReceiverProvince()
	case orderdelivery.FieldReceiverCity:
		return m.ReceiverCity()
	case orderdelivery.FieldReceiverRegion:
		return m.ReceiverRegion()
	case orderdelivery.FieldReceiverDetailAddress:
		return m.ReceiverDetailAddress()
	case orderdelivery.FieldReceiveTime:
		return m.ReceiveTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderDeliveryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderdelivery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderdelivery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderdelivery.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderdelivery.FieldSn:
		return m.OldSn(ctx)
	case orderdelivery.FieldDeliveryCompany:
		return m.OldDeliveryCompany(ctx)
	case orderdelivery.FieldDeliveryTime:
		return m.OldDeliveryTime(ctx)
	case orderdelivery.FieldReceiverName:
		return m.OldReceiverName(ctx)
	case orderdelivery.FieldReceiverPhone:
		return m.OldReceiverPhone(ctx)
	case orderdelivery.FieldReceiverPostCode:
		return m.OldReceiverPostCode(ctx)
	case orderdelivery.FieldReceiverProvince:
		return m.OldReceiverProvince(ctx)
	case orderdelivery.FieldReceiverCity:
		return m.OldReceiverCity(ctx)
	case orderdelivery.FieldReceiverRegion:
		return m.OldReceiverRegion(ctx)
	case orderdelivery.FieldReceiverDetailAddress:
		return m.OldReceiverDetailAddress(ctx)
	case orderdelivery.FieldReceiveTime:
		return m.OldReceiveTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderDelivery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDeliveryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderdelivery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderdelivery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderdelivery.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderdelivery.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case orderdelivery.FieldDeliveryCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryCompany(v)
		return nil
	case orderdelivery.FieldDeliveryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryTime(v)
		return nil
	case orderdelivery.FieldReceiverName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverName(v)
		return nil
	case orderdelivery.FieldReceiverPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverPhone(v)
		return nil
	case orderdelivery.FieldReceiverPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverPostCode(v)
		return nil
	case orderdelivery.FieldReceiverProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverProvince(v)
		return nil
	case orderdelivery.FieldReceiverCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverCity(v)
		return nil
	case orderdelivery.FieldReceiverRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverRegion(v)
		return nil
	case orderdelivery.FieldReceiverDetailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverDetailAddress(v)
		return nil
	case orderdelivery.FieldReceiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDelivery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderDeliveryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderDeliveryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDeliveryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderDelivery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderDeliveryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderdelivery.FieldCreatedAt) {
		fields = append(fields, orderdelivery.FieldCreatedAt)
	}
	if m.FieldCleared(orderdelivery.FieldUpdatedAt) {
		fields = append(fields, orderdelivery.FieldUpdatedAt)
	}
	if m.FieldCleared(orderdelivery.FieldOrderID) {
		fields = append(fields, orderdelivery.FieldOrderID)
	}
	if m.FieldCleared(orderdelivery.FieldDeliveryCompany) {
		fields = append(fields, orderdelivery.FieldDeliveryCompany)
	}
	if m.FieldCleared(orderdelivery.FieldDeliveryTime) {
		fields = append(fields, orderdelivery.FieldDeliveryTime)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverName) {
		fields = append(fields, orderdelivery.FieldReceiverName)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverPhone) {
		fields = append(fields, orderdelivery.FieldReceiverPhone)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverPostCode) {
		fields = append(fields, orderdelivery.FieldReceiverPostCode)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverProvince) {
		fields = append(fields, orderdelivery.FieldReceiverProvince)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverCity) {
		fields = append(fields, orderdelivery.FieldReceiverCity)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverRegion) {
		fields = append(fields, orderdelivery.FieldReceiverRegion)
	}
	if m.FieldCleared(orderdelivery.FieldReceiverDetailAddress) {
		fields = append(fields, orderdelivery.FieldReceiverDetailAddress)
	}
	if m.FieldCleared(orderdelivery.FieldReceiveTime) {
		fields = append(fields, orderdelivery.FieldReceiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderDeliveryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderDeliveryMutation) ClearField(name string) error {
	switch name {
	case orderdelivery.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderdelivery.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderdelivery.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderdelivery.FieldDeliveryCompany:
		m.ClearDeliveryCompany()
		return nil
	case orderdelivery.FieldDeliveryTime:
		m.ClearDeliveryTime()
		return nil
	case orderdelivery.FieldReceiverName:
		m.ClearReceiverName()
		return nil
	case orderdelivery.FieldReceiverPhone:
		m.ClearReceiverPhone()
		return nil
	case orderdelivery.FieldReceiverPostCode:
		m.ClearReceiverPostCode()
		return nil
	case orderdelivery.FieldReceiverProvince:
		m.ClearReceiverProvince()
		return nil
	case orderdelivery.FieldReceiverCity:
		m.ClearReceiverCity()
		return nil
	case orderdelivery.FieldReceiverRegion:
		m.ClearReceiverRegion()
		return nil
	case orderdelivery.FieldReceiverDetailAddress:
		m.ClearReceiverDetailAddress()
		return nil
	case orderdelivery.FieldReceiveTime:
		m.ClearReceiveTime()
		return nil
	}
	return fmt.Errorf("unknown OrderDelivery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderDeliveryMutation) ResetField(name string) error {
	switch name {
	case orderdelivery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderdelivery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderdelivery.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderdelivery.FieldSn:
		m.ResetSn()
		return nil
	case orderdelivery.FieldDeliveryCompany:
		m.ResetDeliveryCompany()
		return nil
	case orderdelivery.FieldDeliveryTime:
		m.ResetDeliveryTime()
		return nil
	case orderdelivery.FieldReceiverName:
		m.ResetReceiverName()
		return nil
	case orderdelivery.FieldReceiverPhone:
		m.ResetReceiverPhone()
		return nil
	case orderdelivery.FieldReceiverPostCode:
		m.ResetReceiverPostCode()
		return nil
	case orderdelivery.FieldReceiverProvince:
		m.ResetReceiverProvince()
		return nil
	case orderdelivery.FieldReceiverCity:
		m.ResetReceiverCity()
		return nil
	case orderdelivery.FieldReceiverRegion:
		m.ResetReceiverRegion()
		return nil
	case orderdelivery.FieldReceiverDetailAddress:
		m.ResetReceiverDetailAddress()
		return nil
	case orderdelivery.FieldReceiveTime:
		m.ResetReceiveTime()
		return nil
	}
	return fmt.Errorf("unknown OrderDelivery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderDeliveryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderdelivery.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderDeliveryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderdelivery.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderDeliveryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderDeliveryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderDeliveryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderdelivery.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderDeliveryMutation) EdgeCleared(name string) bool {
	switch name {
	case orderdelivery.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderDeliveryMutation) ClearEdge(name string) error {
	switch name {
	case orderdelivery.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderDelivery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderDeliveryMutation) ResetEdge(name string) error {
	switch name {
	case orderdelivery.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderDelivery edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	sn                  *string
	product_cate_id     *int
	addproduct_cate_id  *int
	product_id          *int
	addproduct_id       *int
	product_pic         *string
	product_name        *string
	product_sn          *int
	addproduct_sn       *int
	product_price       *float64
	addproduct_price    *float64
	quantity            *int
	addquantity         *int
	product_specs_id    *int
	addproduct_specs_id *int
	product_specs_sn    *string
	product_specs_attr  *string
	clearedFields       map[string]struct{}
	_order              *int
	cleared_order       bool
	done                bool
	oldValue            func(context.Context) (*OrderItem, error)
	predicates          []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderitem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderitem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderitem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderitem.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetSn sets the "sn" field.
func (m *OrderItemMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *OrderItemMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *OrderItemMutation) ResetSn() {
	m.sn = nil
}

// SetProductCateID sets the "product_cate_id" field.
func (m *OrderItemMutation) SetProductCateID(i int) {
	m.product_cate_id = &i
	m.addproduct_cate_id = nil
}

// ProductCateID returns the value of the "product_cate_id" field in the mutation.
func (m *OrderItemMutation) ProductCateID() (r int, exists bool) {
	v := m.product_cate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCateID returns the old "product_cate_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductCateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductCateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductCateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCateID: %w", err)
	}
	return oldValue.ProductCateID, nil
}

// AddProductCateID adds i to the "product_cate_id" field.
func (m *OrderItemMutation) AddProductCateID(i int) {
	if m.addproduct_cate_id != nil {
		*m.addproduct_cate_id += i
	} else {
		m.addproduct_cate_id = &i
	}
}

// AddedProductCateID returns the value that was added to the "product_cate_id" field in this mutation.
func (m *OrderItemMutation) AddedProductCateID() (r int, exists bool) {
	v := m.addproduct_cate_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCateID resets all changes to the "product_cate_id" field.
func (m *OrderItemMutation) ResetProductCateID() {
	m.product_cate_id = nil
	m.addproduct_cate_id = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductPic sets the "product_pic" field.
func (m *OrderItemMutation) SetProductPic(s string) {
	m.product_pic = &s
}

// ProductPic returns the value of the "product_pic" field in the mutation.
func (m *OrderItemMutation) ProductPic() (r string, exists bool) {
	v := m.product_pic
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPic returns the old "product_pic" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPic: %w", err)
	}
	return oldValue.ProductPic, nil
}

// ResetProductPic resets all changes to the "product_pic" field.
func (m *OrderItemMutation) ResetProductPic() {
	m.product_pic = nil
}

// SetProductName sets the "product_name" field.
func (m *OrderItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *OrderItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *OrderItemMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductSn sets the "product_sn" field.
func (m *OrderItemMutation) SetProductSn(i int) {
	m.product_sn = &i
	m.addproduct_sn = nil
}

// ProductSn returns the value of the "product_sn" field in the mutation.
func (m *OrderItemMutation) ProductSn() (r int, exists bool) {
	v := m.product_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSn returns the old "product_sn" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductSn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSn: %w", err)
	}
	return oldValue.ProductSn, nil
}

// AddProductSn adds i to the "product_sn" field.
func (m *OrderItemMutation) AddProductSn(i int) {
	if m.addproduct_sn != nil {
		*m.addproduct_sn += i
	} else {
		m.addproduct_sn = &i
	}
}

// AddedProductSn returns the value that was added to the "product_sn" field in this mutation.
func (m *OrderItemMutation) AddedProductSn() (r int, exists bool) {
	v := m.addproduct_sn
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductSn resets all changes to the "product_sn" field.
func (m *OrderItemMutation) ResetProductSn() {
	m.product_sn = nil
	m.addproduct_sn = nil
}

// SetProductPrice sets the "product_price" field.
func (m *OrderItemMutation) SetProductPrice(f float64) {
	m.product_price = &f
	m.addproduct_price = nil
}

// ProductPrice returns the value of the "product_price" field in the mutation.
func (m *OrderItemMutation) ProductPrice() (r float64, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old "product_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds f to the "product_price" field.
func (m *OrderItemMutation) AddProductPrice(f float64) {
	if m.addproduct_price != nil {
		*m.addproduct_price += f
	} else {
		m.addproduct_price = &f
	}
}

// AddedProductPrice returns the value that was added to the "product_price" field in this mutation.
func (m *OrderItemMutation) AddedProductPrice() (r float64, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice resets all changes to the "product_price" field.
func (m *OrderItemMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetProductSpecsID sets the "product_specs_id" field.
func (m *OrderItemMutation) SetProductSpecsID(i int) {
	m.product_specs_id = &i
	m.addproduct_specs_id = nil
}

// ProductSpecsID returns the value of the "product_specs_id" field in the mutation.
func (m *OrderItemMutation) ProductSpecsID() (r int, exists bool) {
	v := m.product_specs_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecsID returns the old "product_specs_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductSpecsID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductSpecsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductSpecsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecsID: %w", err)
	}
	return oldValue.ProductSpecsID, nil
}

// AddProductSpecsID adds i to the "product_specs_id" field.
func (m *OrderItemMutation) AddProductSpecsID(i int) {
	if m.addproduct_specs_id != nil {
		*m.addproduct_specs_id += i
	} else {
		m.addproduct_specs_id = &i
	}
}

// AddedProductSpecsID returns the value that was added to the "product_specs_id" field in this mutation.
func (m *OrderItemMutation) AddedProductSpecsID() (r int, exists bool) {
	v := m.addproduct_specs_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductSpecsID resets all changes to the "product_specs_id" field.
func (m *OrderItemMutation) ResetProductSpecsID() {
	m.product_specs_id = nil
	m.addproduct_specs_id = nil
}

// SetProductSpecsSn sets the "product_specs_sn" field.
func (m *OrderItemMutation) SetProductSpecsSn(s string) {
	m.product_specs_sn = &s
}

// ProductSpecsSn returns the value of the "product_specs_sn" field in the mutation.
func (m *OrderItemMutation) ProductSpecsSn() (r string, exists bool) {
	v := m.product_specs_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecsSn returns the old "product_specs_sn" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductSpecsSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductSpecsSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductSpecsSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecsSn: %w", err)
	}
	return oldValue.ProductSpecsSn, nil
}

// ResetProductSpecsSn resets all changes to the "product_specs_sn" field.
func (m *OrderItemMutation) ResetProductSpecsSn() {
	m.product_specs_sn = nil
}

// SetProductSpecsAttr sets the "product_specs_attr" field.
func (m *OrderItemMutation) SetProductSpecsAttr(s string) {
	m.product_specs_attr = &s
}

// ProductSpecsAttr returns the value of the "product_specs_attr" field in the mutation.
func (m *OrderItemMutation) ProductSpecsAttr() (r string, exists bool) {
	v := m.product_specs_attr
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecsAttr returns the old "product_specs_attr" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductSpecsAttr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductSpecsAttr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductSpecsAttr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecsAttr: %w", err)
	}
	return oldValue.ProductSpecsAttr, nil
}

// ResetProductSpecsAttr resets all changes to the "product_specs_attr" field.
func (m *OrderItemMutation) ResetProductSpecsAttr() {
	m.product_specs_attr = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.sn != nil {
		fields = append(fields, orderitem.FieldSn)
	}
	if m.product_cate_id != nil {
		fields = append(fields, orderitem.FieldProductCateID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.product_pic != nil {
		fields = append(fields, orderitem.FieldProductPic)
	}
	if m.product_name != nil {
		fields = append(fields, orderitem.FieldProductName)
	}
	if m.product_sn != nil {
		fields = append(fields, orderitem.FieldProductSn)
	}
	if m.product_price != nil {
		fields = append(fields, orderitem.FieldProductPrice)
	}
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.product_specs_id != nil {
		fields = append(fields, orderitem.FieldProductSpecsID)
	}
	if m.product_specs_sn != nil {
		fields = append(fields, orderitem.FieldProductSpecsSn)
	}
	if m.product_specs_attr != nil {
		fields = append(fields, orderitem.FieldProductSpecsAttr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldSn:
		return m.Sn()
	case orderitem.FieldProductCateID:
		return m.ProductCateID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldProductPic:
		return m.ProductPic()
	case orderitem.FieldProductName:
		return m.ProductName()
	case orderitem.FieldProductSn:
		return m.ProductSn()
	case orderitem.FieldProductPrice:
		return m.ProductPrice()
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldProductSpecsID:
		return m.ProductSpecsID()
	case orderitem.FieldProductSpecsSn:
		return m.ProductSpecsSn()
	case orderitem.FieldProductSpecsAttr:
		return m.ProductSpecsAttr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldSn:
		return m.OldSn(ctx)
	case orderitem.FieldProductCateID:
		return m.OldProductCateID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldProductPic:
		return m.OldProductPic(ctx)
	case orderitem.FieldProductName:
		return m.OldProductName(ctx)
	case orderitem.FieldProductSn:
		return m.OldProductSn(ctx)
	case orderitem.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldProductSpecsID:
		return m.OldProductSpecsID(ctx)
	case orderitem.FieldProductSpecsSn:
		return m.OldProductSpecsSn(ctx)
	case orderitem.FieldProductSpecsAttr:
		return m.OldProductSpecsAttr(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case orderitem.FieldProductCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCateID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldProductPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPic(v)
		return nil
	case orderitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case orderitem.FieldProductSn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSn(v)
		return nil
	case orderitem.FieldProductPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldProductSpecsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecsID(v)
		return nil
	case orderitem.FieldProductSpecsSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecsSn(v)
		return nil
	case orderitem.FieldProductSpecsAttr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecsAttr(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_cate_id != nil {
		fields = append(fields, orderitem.FieldProductCateID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addproduct_sn != nil {
		fields = append(fields, orderitem.FieldProductSn)
	}
	if m.addproduct_price != nil {
		fields = append(fields, orderitem.FieldProductPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.addproduct_specs_id != nil {
		fields = append(fields, orderitem.FieldProductSpecsID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldProductCateID:
		return m.AddedProductCateID()
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldProductSn:
		return m.AddedProductSn()
	case orderitem.FieldProductPrice:
		return m.AddedProductPrice()
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	case orderitem.FieldProductSpecsID:
		return m.AddedProductSpecsID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldProductCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCateID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldProductSn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductSn(v)
		return nil
	case orderitem.FieldProductPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitem.FieldProductSpecsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductSpecsID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldCreatedAt) {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.FieldCleared(orderitem.FieldUpdatedAt) {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldSn:
		m.ResetSn()
		return nil
	case orderitem.FieldProductCateID:
		m.ResetProductCateID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldProductPic:
		m.ResetProductPic()
		return nil
	case orderitem.FieldProductName:
		m.ResetProductName()
		return nil
	case orderitem.FieldProductSn:
		m.ResetProductSn()
		return nil
	case orderitem.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldProductSpecsID:
		m.ResetProductSpecsID()
		return nil
	case orderitem.FieldProductSpecsSn:
		m.ResetProductSpecsSn()
		return nil
	case orderitem.FieldProductSpecsAttr:
		m.ResetProductSpecsAttr()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPayMutation represents an operation that mutates the OrderPay nodes in the graph.
type OrderPayMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	sn            *string
	price         *float64
	addprice      *float64
	pay_mode      *string
	clearedFields map[string]struct{}
	_order        *int
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderPay, error)
	predicates    []predicate.OrderPay
}

var _ ent.Mutation = (*OrderPayMutation)(nil)

// orderpayOption allows management of the mutation configuration using functional options.
type orderpayOption func(*OrderPayMutation)

// newOrderPayMutation creates new mutation for the OrderPay entity.
func newOrderPayMutation(c config, op Op, opts ...orderpayOption) *OrderPayMutation {
	m := &OrderPayMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPayID sets the ID field of the mutation.
func withOrderPayID(id int) orderpayOption {
	return func(m *OrderPayMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPay
		)
		m.oldValue = func(ctx context.Context) (*OrderPay, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPay sets the old OrderPay of the mutation.
func withOrderPay(node *OrderPay) orderpayOption {
	return func(m *OrderPayMutation) {
		m.oldValue = func(context.Context) (*OrderPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPayMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderPayMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderpay.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderPayMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPayMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderpay.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderPayMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderpay.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderPayMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderpay.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderPayMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderPayMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderPayMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderPayMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderPayMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderpay.FieldOrderID)
}

// SetUserID sets the "user_id" field.
func (m *OrderPayMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderPayMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderPayMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderPayMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderPayMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetSn sets the "sn" field.
func (m *OrderPayMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *OrderPayMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *OrderPayMutation) ResetSn() {
	m.sn = nil
}

// SetPrice sets the "price" field.
func (m *OrderPayMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderPayMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *OrderPayMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderPayMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderPayMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPayMode sets the "pay_mode" field.
func (m *OrderPayMutation) SetPayMode(s string) {
	m.pay_mode = &s
}

// PayMode returns the value of the "pay_mode" field in the mutation.
func (m *OrderPayMutation) PayMode() (r string, exists bool) {
	v := m.pay_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldPayMode returns the old "pay_mode" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayMode: %w", err)
	}
	return oldValue.PayMode, nil
}

// ClearPayMode clears the value of the "pay_mode" field.
func (m *OrderPayMutation) ClearPayMode() {
	m.pay_mode = nil
	m.clearedFields[orderpay.FieldPayMode] = struct{}{}
}

// PayModeCleared returns if the "pay_mode" field was cleared in this mutation.
func (m *OrderPayMutation) PayModeCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayMode]
	return ok
}

// ResetPayMode resets all changes to the "pay_mode" field.
func (m *OrderPayMutation) ResetPayMode() {
	m.pay_mode = nil
	delete(m.clearedFields, orderpay.FieldPayMode)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderPayMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderPayMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderPayMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderPayMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderPayMutation builder.
func (m *OrderPayMutation) Where(ps ...predicate.OrderPay) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderPayMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderPay).
func (m *OrderPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPayMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.user_id != nil {
		fields = append(fields, orderpay.FieldUserID)
	}
	if m.sn != nil {
		fields = append(fields, orderpay.FieldSn)
	}
	if m.price != nil {
		fields = append(fields, orderpay.FieldPrice)
	}
	if m.pay_mode != nil {
		fields = append(fields, orderpay.FieldPayMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.CreatedAt()
	case orderpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpay.FieldOrderID:
		return m.OrderID()
	case orderpay.FieldUserID:
		return m.UserID()
	case orderpay.FieldSn:
		return m.Sn()
	case orderpay.FieldPrice:
		return m.Price()
	case orderpay.FieldPayMode:
		return m.PayMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpay.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderpay.FieldUserID:
		return m.OldUserID(ctx)
	case orderpay.FieldSn:
		return m.OldSn(ctx)
	case orderpay.FieldPrice:
		return m.OldPrice(ctx)
	case orderpay.FieldPayMode:
		return m.OldPayMode(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpay.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderpay.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderpay.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case orderpay.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderpay.FieldPayMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayMode(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPayMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, orderpay.FieldUserID)
	}
	if m.addprice != nil {
		fields = append(fields, orderpay.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldUserID:
		return m.AddedUserID()
	case orderpay.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orderpay.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpay.FieldCreatedAt) {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.FieldCleared(orderpay.FieldUpdatedAt) {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.FieldCleared(orderpay.FieldOrderID) {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.FieldCleared(orderpay.FieldPayMode) {
		fields = append(fields, orderpay.FieldPayMode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPayMutation) ClearField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderpay.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderpay.FieldPayMode:
		m.ClearPayMode()
		return nil
	}
	return fmt.Errorf("unknown OrderPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPayMutation) ResetField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpay.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderpay.FieldUserID:
		m.ResetUserID()
		return nil
	case orderpay.FieldSn:
		m.ResetSn()
		return nil
	case orderpay.FieldPrice:
		m.ResetPrice()
		return nil
	case orderpay.FieldPayMode:
		m.ResetPayMode()
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpay.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPayMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPayMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpay.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPayMutation) ClearEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPayMutation) ResetEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay edge %s", name)
}

// OrderSettingMutation represents an operation that mutates the OrderSetting nodes in the graph.
type OrderSettingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	order_overtime      *int
	addorder_overtime   *int
	confirm_overtime    *int
	addconfirm_overtime *int
	finish_overtime     *int
	addfinish_overtime  *int
	comment_overtime    *int
	addcomment_overtime *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*OrderSetting, error)
	predicates          []predicate.OrderSetting
}

var _ ent.Mutation = (*OrderSettingMutation)(nil)

// ordersettingOption allows management of the mutation configuration using functional options.
type ordersettingOption func(*OrderSettingMutation)

// newOrderSettingMutation creates new mutation for the OrderSetting entity.
func newOrderSettingMutation(c config, op Op, opts ...ordersettingOption) *OrderSettingMutation {
	m := &OrderSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSettingID sets the ID field of the mutation.
func withOrderSettingID(id int) ordersettingOption {
	return func(m *OrderSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSetting
		)
		m.oldValue = func(ctx context.Context) (*OrderSetting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSetting sets the old OrderSetting of the mutation.
func withOrderSetting(node *OrderSetting) ordersettingOption {
	return func(m *OrderSettingMutation) {
		m.oldValue = func(context.Context) (*OrderSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[ordersetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, ordersetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[ordersetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, ordersetting.FieldUpdatedAt)
}

// SetOrderOvertime sets the "order_overtime" field.
func (m *OrderSettingMutation) SetOrderOvertime(i int) {
	m.order_overtime = &i
	m.addorder_overtime = nil
}

// OrderOvertime returns the value of the "order_overtime" field in the mutation.
func (m *OrderSettingMutation) OrderOvertime() (r int, exists bool) {
	v := m.order_overtime
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderOvertime returns the old "order_overtime" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldOrderOvertime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderOvertime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderOvertime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderOvertime: %w", err)
	}
	return oldValue.OrderOvertime, nil
}

// AddOrderOvertime adds i to the "order_overtime" field.
func (m *OrderSettingMutation) AddOrderOvertime(i int) {
	if m.addorder_overtime != nil {
		*m.addorder_overtime += i
	} else {
		m.addorder_overtime = &i
	}
}

// AddedOrderOvertime returns the value that was added to the "order_overtime" field in this mutation.
func (m *OrderSettingMutation) AddedOrderOvertime() (r int, exists bool) {
	v := m.addorder_overtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderOvertime clears the value of the "order_overtime" field.
func (m *OrderSettingMutation) ClearOrderOvertime() {
	m.order_overtime = nil
	m.addorder_overtime = nil
	m.clearedFields[ordersetting.FieldOrderOvertime] = struct{}{}
}

// OrderOvertimeCleared returns if the "order_overtime" field was cleared in this mutation.
func (m *OrderSettingMutation) OrderOvertimeCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldOrderOvertime]
	return ok
}

// ResetOrderOvertime resets all changes to the "order_overtime" field.
func (m *OrderSettingMutation) ResetOrderOvertime() {
	m.order_overtime = nil
	m.addorder_overtime = nil
	delete(m.clearedFields, ordersetting.FieldOrderOvertime)
}

// SetConfirmOvertime sets the "confirm_overtime" field.
func (m *OrderSettingMutation) SetConfirmOvertime(i int) {
	m.confirm_overtime = &i
	m.addconfirm_overtime = nil
}

// ConfirmOvertime returns the value of the "confirm_overtime" field in the mutation.
func (m *OrderSettingMutation) ConfirmOvertime() (r int, exists bool) {
	v := m.confirm_overtime
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmOvertime returns the old "confirm_overtime" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldConfirmOvertime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfirmOvertime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfirmOvertime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmOvertime: %w", err)
	}
	return oldValue.ConfirmOvertime, nil
}

// AddConfirmOvertime adds i to the "confirm_overtime" field.
func (m *OrderSettingMutation) AddConfirmOvertime(i int) {
	if m.addconfirm_overtime != nil {
		*m.addconfirm_overtime += i
	} else {
		m.addconfirm_overtime = &i
	}
}

// AddedConfirmOvertime returns the value that was added to the "confirm_overtime" field in this mutation.
func (m *OrderSettingMutation) AddedConfirmOvertime() (r int, exists bool) {
	v := m.addconfirm_overtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfirmOvertime clears the value of the "confirm_overtime" field.
func (m *OrderSettingMutation) ClearConfirmOvertime() {
	m.confirm_overtime = nil
	m.addconfirm_overtime = nil
	m.clearedFields[ordersetting.FieldConfirmOvertime] = struct{}{}
}

// ConfirmOvertimeCleared returns if the "confirm_overtime" field was cleared in this mutation.
func (m *OrderSettingMutation) ConfirmOvertimeCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldConfirmOvertime]
	return ok
}

// ResetConfirmOvertime resets all changes to the "confirm_overtime" field.
func (m *OrderSettingMutation) ResetConfirmOvertime() {
	m.confirm_overtime = nil
	m.addconfirm_overtime = nil
	delete(m.clearedFields, ordersetting.FieldConfirmOvertime)
}

// SetFinishOvertime sets the "finish_overtime" field.
func (m *OrderSettingMutation) SetFinishOvertime(i int) {
	m.finish_overtime = &i
	m.addfinish_overtime = nil
}

// FinishOvertime returns the value of the "finish_overtime" field in the mutation.
func (m *OrderSettingMutation) FinishOvertime() (r int, exists bool) {
	v := m.finish_overtime
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishOvertime returns the old "finish_overtime" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldFinishOvertime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishOvertime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishOvertime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishOvertime: %w", err)
	}
	return oldValue.FinishOvertime, nil
}

// AddFinishOvertime adds i to the "finish_overtime" field.
func (m *OrderSettingMutation) AddFinishOvertime(i int) {
	if m.addfinish_overtime != nil {
		*m.addfinish_overtime += i
	} else {
		m.addfinish_overtime = &i
	}
}

// AddedFinishOvertime returns the value that was added to the "finish_overtime" field in this mutation.
func (m *OrderSettingMutation) AddedFinishOvertime() (r int, exists bool) {
	v := m.addfinish_overtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearFinishOvertime clears the value of the "finish_overtime" field.
func (m *OrderSettingMutation) ClearFinishOvertime() {
	m.finish_overtime = nil
	m.addfinish_overtime = nil
	m.clearedFields[ordersetting.FieldFinishOvertime] = struct{}{}
}

// FinishOvertimeCleared returns if the "finish_overtime" field was cleared in this mutation.
func (m *OrderSettingMutation) FinishOvertimeCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldFinishOvertime]
	return ok
}

// ResetFinishOvertime resets all changes to the "finish_overtime" field.
func (m *OrderSettingMutation) ResetFinishOvertime() {
	m.finish_overtime = nil
	m.addfinish_overtime = nil
	delete(m.clearedFields, ordersetting.FieldFinishOvertime)
}

// SetCommentOvertime sets the "comment_overtime" field.
func (m *OrderSettingMutation) SetCommentOvertime(i int) {
	m.comment_overtime = &i
	m.addcomment_overtime = nil
}

// CommentOvertime returns the value of the "comment_overtime" field in the mutation.
func (m *OrderSettingMutation) CommentOvertime() (r int, exists bool) {
	v := m.comment_overtime
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentOvertime returns the old "comment_overtime" field's value of the OrderSetting entity.
// If the OrderSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSettingMutation) OldCommentOvertime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommentOvertime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommentOvertime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentOvertime: %w", err)
	}
	return oldValue.CommentOvertime, nil
}

// AddCommentOvertime adds i to the "comment_overtime" field.
func (m *OrderSettingMutation) AddCommentOvertime(i int) {
	if m.addcomment_overtime != nil {
		*m.addcomment_overtime += i
	} else {
		m.addcomment_overtime = &i
	}
}

// AddedCommentOvertime returns the value that was added to the "comment_overtime" field in this mutation.
func (m *OrderSettingMutation) AddedCommentOvertime() (r int, exists bool) {
	v := m.addcomment_overtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentOvertime clears the value of the "comment_overtime" field.
func (m *OrderSettingMutation) ClearCommentOvertime() {
	m.comment_overtime = nil
	m.addcomment_overtime = nil
	m.clearedFields[ordersetting.FieldCommentOvertime] = struct{}{}
}

// CommentOvertimeCleared returns if the "comment_overtime" field was cleared in this mutation.
func (m *OrderSettingMutation) CommentOvertimeCleared() bool {
	_, ok := m.clearedFields[ordersetting.FieldCommentOvertime]
	return ok
}

// ResetCommentOvertime resets all changes to the "comment_overtime" field.
func (m *OrderSettingMutation) ResetCommentOvertime() {
	m.comment_overtime = nil
	m.addcomment_overtime = nil
	delete(m.clearedFields, ordersetting.FieldCommentOvertime)
}

// Where appends a list predicates to the OrderSettingMutation builder.
func (m *OrderSettingMutation) Where(ps ...predicate.OrderSetting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderSettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderSetting).
func (m *OrderSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSettingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, ordersetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordersetting.FieldUpdatedAt)
	}
	if m.order_overtime != nil {
		fields = append(fields, ordersetting.FieldOrderOvertime)
	}
	if m.confirm_overtime != nil {
		fields = append(fields, ordersetting.FieldConfirmOvertime)
	}
	if m.finish_overtime != nil {
		fields = append(fields, ordersetting.FieldFinishOvertime)
	}
	if m.comment_overtime != nil {
		fields = append(fields, ordersetting.FieldCommentOvertime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersetting.FieldCreatedAt:
		return m.CreatedAt()
	case ordersetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordersetting.FieldOrderOvertime:
		return m.OrderOvertime()
	case ordersetting.FieldConfirmOvertime:
		return m.ConfirmOvertime()
	case ordersetting.FieldFinishOvertime:
		return m.FinishOvertime()
	case ordersetting.FieldCommentOvertime:
		return m.CommentOvertime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordersetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordersetting.FieldOrderOvertime:
		return m.OldOrderOvertime(ctx)
	case ordersetting.FieldConfirmOvertime:
		return m.OldConfirmOvertime(ctx)
	case ordersetting.FieldFinishOvertime:
		return m.OldFinishOvertime(ctx)
	case ordersetting.FieldCommentOvertime:
		return m.OldCommentOvertime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordersetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordersetting.FieldOrderOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderOvertime(v)
		return nil
	case ordersetting.FieldConfirmOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmOvertime(v)
		return nil
	case ordersetting.FieldFinishOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishOvertime(v)
		return nil
	case ordersetting.FieldCommentOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentOvertime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSettingMutation) AddedFields() []string {
	var fields []string
	if m.addorder_overtime != nil {
		fields = append(fields, ordersetting.FieldOrderOvertime)
	}
	if m.addconfirm_overtime != nil {
		fields = append(fields, ordersetting.FieldConfirmOvertime)
	}
	if m.addfinish_overtime != nil {
		fields = append(fields, ordersetting.FieldFinishOvertime)
	}
	if m.addcomment_overtime != nil {
		fields = append(fields, ordersetting.FieldCommentOvertime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersetting.FieldOrderOvertime:
		return m.AddedOrderOvertime()
	case ordersetting.FieldConfirmOvertime:
		return m.AddedConfirmOvertime()
	case ordersetting.FieldFinishOvertime:
		return m.AddedFinishOvertime()
	case ordersetting.FieldCommentOvertime:
		return m.AddedCommentOvertime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersetting.FieldOrderOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderOvertime(v)
		return nil
	case ordersetting.FieldConfirmOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfirmOvertime(v)
		return nil
	case ordersetting.FieldFinishOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinishOvertime(v)
		return nil
	case ordersetting.FieldCommentOvertime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentOvertime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersetting.FieldCreatedAt) {
		fields = append(fields, ordersetting.FieldCreatedAt)
	}
	if m.FieldCleared(ordersetting.FieldUpdatedAt) {
		fields = append(fields, ordersetting.FieldUpdatedAt)
	}
	if m.FieldCleared(ordersetting.FieldOrderOvertime) {
		fields = append(fields, ordersetting.FieldOrderOvertime)
	}
	if m.FieldCleared(ordersetting.FieldConfirmOvertime) {
		fields = append(fields, ordersetting.FieldConfirmOvertime)
	}
	if m.FieldCleared(ordersetting.FieldFinishOvertime) {
		fields = append(fields, ordersetting.FieldFinishOvertime)
	}
	if m.FieldCleared(ordersetting.FieldCommentOvertime) {
		fields = append(fields, ordersetting.FieldCommentOvertime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSettingMutation) ClearField(name string) error {
	switch name {
	case ordersetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case ordersetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case ordersetting.FieldOrderOvertime:
		m.ClearOrderOvertime()
		return nil
	case ordersetting.FieldConfirmOvertime:
		m.ClearConfirmOvertime()
		return nil
	case ordersetting.FieldFinishOvertime:
		m.ClearFinishOvertime()
		return nil
	case ordersetting.FieldCommentOvertime:
		m.ClearCommentOvertime()
		return nil
	}
	return fmt.Errorf("unknown OrderSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSettingMutation) ResetField(name string) error {
	switch name {
	case ordersetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordersetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordersetting.FieldOrderOvertime:
		m.ResetOrderOvertime()
		return nil
	case ordersetting.FieldConfirmOvertime:
		m.ResetConfirmOvertime()
		return nil
	case ordersetting.FieldFinishOvertime:
		m.ResetFinishOvertime()
		return nil
	case ordersetting.FieldCommentOvertime:
		m.ResetCommentOvertime()
		return nil
	}
	return fmt.Errorf("unknown OrderSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderSetting edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	status        *property.Status
	create_id     *int
	addcreate_id  *int
	clearedFields map[string]struct{}
	cate          *int
	clearedcate   bool
	specs         map[int]struct{}
	removedspecs  map[int]struct{}
	clearedspecs  bool
	done          bool
	oldValue      func(context.Context) (*Product, error)
	predicates    []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[product.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, product.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[product.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, product.FieldUpdatedAt)
}

// SetCateID sets the "cate_id" field.
func (m *ProductMutation) SetCateID(i int) {
	m.cate = &i
}

// CateID returns the value of the "cate_id" field in the mutation.
func (m *ProductMutation) CateID() (r int, exists bool) {
	v := m.cate
	if v == nil {
		return
	}
	return *v, true
}

// OldCateID returns the old "cate_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateID: %w", err)
	}
	return oldValue.CateID, nil
}

// ClearCateID clears the value of the "cate_id" field.
func (m *ProductMutation) ClearCateID() {
	m.cate = nil
	m.clearedFields[product.FieldCateID] = struct{}{}
}

// CateIDCleared returns if the "cate_id" field was cleared in this mutation.
func (m *ProductMutation) CateIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCateID]
	return ok
}

// ResetCateID resets all changes to the "cate_id" field.
func (m *ProductMutation) ResetCateID() {
	m.cate = nil
	delete(m.clearedFields, product.FieldCateID)
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[product.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[product.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, product.FieldName)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(pr property.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r property.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
}

// SetCreateID sets the "create_id" field.
func (m *ProductMutation) SetCreateID(i int) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *ProductMutation) CreateID() (r int, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *ProductMutation) AddCreateID(i int) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *ProductMutation) AddedCreateID() (r int, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *ProductMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[product.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *ProductMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *ProductMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, product.FieldCreateID)
}

// ClearCate clears the "cate" edge to the ProductCate entity.
func (m *ProductMutation) ClearCate() {
	m.clearedcate = true
}

// CateCleared reports if the "cate" edge to the ProductCate entity was cleared.
func (m *ProductMutation) CateCleared() bool {
	return m.CateIDCleared() || m.clearedcate
}

// CateIDs returns the "cate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CateID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CateIDs() (ids []int) {
	if id := m.cate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCate resets all changes to the "cate" edge.
func (m *ProductMutation) ResetCate() {
	m.cate = nil
	m.clearedcate = false
}

// AddSpecIDs adds the "specs" edge to the ProductSpecs entity by ids.
func (m *ProductMutation) AddSpecIDs(ids ...int) {
	if m.specs == nil {
		m.specs = make(map[int]struct{})
	}
	for i := range ids {
		m.specs[ids[i]] = struct{}{}
	}
}

// ClearSpecs clears the "specs" edge to the ProductSpecs entity.
func (m *ProductMutation) ClearSpecs() {
	m.clearedspecs = true
}

// SpecsCleared reports if the "specs" edge to the ProductSpecs entity was cleared.
func (m *ProductMutation) SpecsCleared() bool {
	return m.clearedspecs
}

// RemoveSpecIDs removes the "specs" edge to the ProductSpecs entity by IDs.
func (m *ProductMutation) RemoveSpecIDs(ids ...int) {
	if m.removedspecs == nil {
		m.removedspecs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.specs, ids[i])
		m.removedspecs[ids[i]] = struct{}{}
	}
}

// RemovedSpecs returns the removed IDs of the "specs" edge to the ProductSpecs entity.
func (m *ProductMutation) RemovedSpecsIDs() (ids []int) {
	for id := range m.removedspecs {
		ids = append(ids, id)
	}
	return
}

// SpecsIDs returns the "specs" edge IDs in the mutation.
func (m *ProductMutation) SpecsIDs() (ids []int) {
	for id := range m.specs {
		ids = append(ids, id)
	}
	return
}

// ResetSpecs resets all changes to the "specs" edge.
func (m *ProductMutation) ResetSpecs() {
	m.specs = nil
	m.clearedspecs = false
	m.removedspecs = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.cate != nil {
		fields = append(fields, product.FieldCateID)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.create_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldCateID:
		return m.CateID()
	case product.FieldName:
		return m.Name()
	case product.FieldStatus:
		return m.Status()
	case product.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldCateID:
		return m.OldCateID(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateID(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldCreateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldCreatedAt) {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.FieldCleared(product.FieldUpdatedAt) {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.FieldCleared(product.FieldCateID) {
		fields = append(fields, product.FieldCateID)
	}
	if m.FieldCleared(product.FieldName) {
		fields = append(fields, product.FieldName)
	}
	if m.FieldCleared(product.FieldCreateID) {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case product.FieldCateID:
		m.ClearCateID()
		return nil
	case product.FieldName:
		m.ClearName()
		return nil
	case product.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldCateID:
		m.ResetCateID()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cate != nil {
		edges = append(edges, product.EdgeCate)
	}
	if m.specs != nil {
		edges = append(edges, product.EdgeSpecs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCate:
		if id := m.cate; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeSpecs:
		ids := make([]ent.Value, 0, len(m.specs))
		for id := range m.specs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedspecs != nil {
		edges = append(edges, product.EdgeSpecs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeSpecs:
		ids := make([]ent.Value, 0, len(m.removedspecs))
		for id := range m.removedspecs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcate {
		edges = append(edges, product.EdgeCate)
	}
	if m.clearedspecs {
		edges = append(edges, product.EdgeSpecs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCate:
		return m.clearedcate
	case product.EdgeSpecs:
		return m.clearedspecs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCate:
		m.ClearCate()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCate:
		m.ResetCate()
		return nil
	case product.EdgeSpecs:
		m.ResetSpecs()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductAttributeKeyMutation represents an operation that mutates the ProductAttributeKey nodes in the graph.
type ProductAttributeKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	product_id    *int
	addproduct_id *int
	name          *string
	sort          *int
	addsort       *int
	clearedFields map[string]struct{}
	values        map[int]struct{}
	removedvalues map[int]struct{}
	clearedvalues bool
	done          bool
	oldValue      func(context.Context) (*ProductAttributeKey, error)
	predicates    []predicate.ProductAttributeKey
}

var _ ent.Mutation = (*ProductAttributeKeyMutation)(nil)

// productattributekeyOption allows management of the mutation configuration using functional options.
type productattributekeyOption func(*ProductAttributeKeyMutation)

// newProductAttributeKeyMutation creates new mutation for the ProductAttributeKey entity.
func newProductAttributeKeyMutation(c config, op Op, opts ...productattributekeyOption) *ProductAttributeKeyMutation {
	m := &ProductAttributeKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttributeKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttributeKeyID sets the ID field of the mutation.
func withProductAttributeKeyID(id int) productattributekeyOption {
	return func(m *ProductAttributeKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttributeKey
		)
		m.oldValue = func(ctx context.Context) (*ProductAttributeKey, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttributeKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttributeKey sets the old ProductAttributeKey of the mutation.
func withProductAttributeKey(node *ProductAttributeKey) productattributekeyOption {
	return func(m *ProductAttributeKeyMutation) {
		m.oldValue = func(context.Context) (*ProductAttributeKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttributeKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttributeKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAttributeKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductAttributeKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductAttributeKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductAttributeKey entity.
// If the ProductAttributeKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductAttributeKeyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productattributekey.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductAttributeKeyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productattributekey.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductAttributeKeyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productattributekey.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductAttributeKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductAttributeKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductAttributeKey entity.
// If the ProductAttributeKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductAttributeKeyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productattributekey.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductAttributeKeyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productattributekey.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductAttributeKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productattributekey.FieldUpdatedAt)
}

// SetProductID sets the "product_id" field.
func (m *ProductAttributeKeyMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductAttributeKeyMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductAttributeKey entity.
// If the ProductAttributeKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeKeyMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ProductAttributeKeyMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ProductAttributeKeyMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductAttributeKeyMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[productattributekey.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductAttributeKeyMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productattributekey.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductAttributeKeyMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, productattributekey.FieldProductID)
}

// SetName sets the "name" field.
func (m *ProductAttributeKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductAttributeKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductAttributeKey entity.
// If the ProductAttributeKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductAttributeKeyMutation) ClearName() {
	m.name = nil
	m.clearedFields[productattributekey.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductAttributeKeyMutation) NameCleared() bool {
	_, ok := m.clearedFields[productattributekey.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductAttributeKeyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, productattributekey.FieldName)
}

// SetSort sets the "sort" field.
func (m *ProductAttributeKeyMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ProductAttributeKeyMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ProductAttributeKey entity.
// If the ProductAttributeKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeKeyMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ProductAttributeKeyMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ProductAttributeKeyMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ProductAttributeKeyMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// AddValueIDs adds the "values" edge to the ProductAttributeValue entity by ids.
func (m *ProductAttributeKeyMutation) AddValueIDs(ids ...int) {
	if m.values == nil {
		m.values = make(map[int]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the ProductAttributeValue entity.
func (m *ProductAttributeKeyMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the ProductAttributeValue entity was cleared.
func (m *ProductAttributeKeyMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the ProductAttributeValue entity by IDs.
func (m *ProductAttributeKeyMutation) RemoveValueIDs(ids ...int) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the ProductAttributeValue entity.
func (m *ProductAttributeKeyMutation) RemovedValuesIDs() (ids []int) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *ProductAttributeKeyMutation) ValuesIDs() (ids []int) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *ProductAttributeKeyMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the ProductAttributeKeyMutation builder.
func (m *ProductAttributeKeyMutation) Where(ps ...predicate.ProductAttributeKey) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductAttributeKeyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAttributeKey).
func (m *ProductAttributeKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttributeKeyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productattributekey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productattributekey.FieldUpdatedAt)
	}
	if m.product_id != nil {
		fields = append(fields, productattributekey.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, productattributekey.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, productattributekey.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttributeKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattributekey.FieldCreatedAt:
		return m.CreatedAt()
	case productattributekey.FieldUpdatedAt:
		return m.UpdatedAt()
	case productattributekey.FieldProductID:
		return m.ProductID()
	case productattributekey.FieldName:
		return m.Name()
	case productattributekey.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttributeKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattributekey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productattributekey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productattributekey.FieldProductID:
		return m.OldProductID(ctx)
	case productattributekey.FieldName:
		return m.OldName(ctx)
	case productattributekey.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttributeKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttributeKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattributekey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productattributekey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productattributekey.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productattributekey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productattributekey.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttributeKeyMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, productattributekey.FieldProductID)
	}
	if m.addsort != nil {
		fields = append(fields, productattributekey.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttributeKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattributekey.FieldProductID:
		return m.AddedProductID()
	case productattributekey.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttributeKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattributekey.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case productattributekey.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttributeKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productattributekey.FieldCreatedAt) {
		fields = append(fields, productattributekey.FieldCreatedAt)
	}
	if m.FieldCleared(productattributekey.FieldUpdatedAt) {
		fields = append(fields, productattributekey.FieldUpdatedAt)
	}
	if m.FieldCleared(productattributekey.FieldProductID) {
		fields = append(fields, productattributekey.FieldProductID)
	}
	if m.FieldCleared(productattributekey.FieldName) {
		fields = append(fields, productattributekey.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttributeKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttributeKeyMutation) ClearField(name string) error {
	switch name {
	case productattributekey.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productattributekey.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case productattributekey.FieldProductID:
		m.ClearProductID()
		return nil
	case productattributekey.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttributeKeyMutation) ResetField(name string) error {
	switch name {
	case productattributekey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productattributekey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productattributekey.FieldProductID:
		m.ResetProductID()
		return nil
	case productattributekey.FieldName:
		m.ResetName()
		return nil
	case productattributekey.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttributeKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.values != nil {
		edges = append(edges, productattributekey.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttributeKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productattributekey.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttributeKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalues != nil {
		edges = append(edges, productattributekey.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttributeKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productattributekey.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttributeKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalues {
		edges = append(edges, productattributekey.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttributeKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case productattributekey.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttributeKeyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductAttributeKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttributeKeyMutation) ResetEdge(name string) error {
	switch name {
	case productattributekey.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeKey edge %s", name)
}

// ProductAttributeValueMutation represents an operation that mutates the ProductAttributeValue nodes in the graph.
type ProductAttributeValueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	value         *string
	sort          *int
	addsort       *int
	clearedFields map[string]struct{}
	key           *int
	clearedkey    bool
	items         map[int]struct{}
	removeditems  map[int]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*ProductAttributeValue, error)
	predicates    []predicate.ProductAttributeValue
}

var _ ent.Mutation = (*ProductAttributeValueMutation)(nil)

// productattributevalueOption allows management of the mutation configuration using functional options.
type productattributevalueOption func(*ProductAttributeValueMutation)

// newProductAttributeValueMutation creates new mutation for the ProductAttributeValue entity.
func newProductAttributeValueMutation(c config, op Op, opts ...productattributevalueOption) *ProductAttributeValueMutation {
	m := &ProductAttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttributeValueID sets the ID field of the mutation.
func withProductAttributeValueID(id int) productattributevalueOption {
	return func(m *ProductAttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttributeValue
		)
		m.oldValue = func(ctx context.Context) (*ProductAttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttributeValue sets the old ProductAttributeValue of the mutation.
func withProductAttributeValue(node *ProductAttributeValue) productattributevalueOption {
	return func(m *ProductAttributeValueMutation) {
		m.oldValue = func(context.Context) (*ProductAttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAttributeValueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductAttributeValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductAttributeValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductAttributeValue entity.
// If the ProductAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductAttributeValueMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productattributevalue.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductAttributeValueMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productattributevalue.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductAttributeValueMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productattributevalue.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductAttributeValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductAttributeValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductAttributeValue entity.
// If the ProductAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductAttributeValueMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productattributevalue.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductAttributeValueMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productattributevalue.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductAttributeValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productattributevalue.FieldUpdatedAt)
}

// SetKeyID sets the "key_id" field.
func (m *ProductAttributeValueMutation) SetKeyID(i int) {
	m.key = &i
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *ProductAttributeValueMutation) KeyID() (r int, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the ProductAttributeValue entity.
// If the ProductAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeValueMutation) OldKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// ClearKeyID clears the value of the "key_id" field.
func (m *ProductAttributeValueMutation) ClearKeyID() {
	m.key = nil
	m.clearedFields[productattributevalue.FieldKeyID] = struct{}{}
}

// KeyIDCleared returns if the "key_id" field was cleared in this mutation.
func (m *ProductAttributeValueMutation) KeyIDCleared() bool {
	_, ok := m.clearedFields[productattributevalue.FieldKeyID]
	return ok
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *ProductAttributeValueMutation) ResetKeyID() {
	m.key = nil
	delete(m.clearedFields, productattributevalue.FieldKeyID)
}

// SetValue sets the "value" field.
func (m *ProductAttributeValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ProductAttributeValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ProductAttributeValue entity.
// If the ProductAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *ProductAttributeValueMutation) ClearValue() {
	m.value = nil
	m.clearedFields[productattributevalue.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *ProductAttributeValueMutation) ValueCleared() bool {
	_, ok := m.clearedFields[productattributevalue.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *ProductAttributeValueMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, productattributevalue.FieldValue)
}

// SetSort sets the "sort" field.
func (m *ProductAttributeValueMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ProductAttributeValueMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ProductAttributeValue entity.
// If the ProductAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttributeValueMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ProductAttributeValueMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ProductAttributeValueMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ProductAttributeValueMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// ClearKey clears the "key" edge to the ProductAttributeKey entity.
func (m *ProductAttributeValueMutation) ClearKey() {
	m.clearedkey = true
}

// KeyCleared reports if the "key" edge to the ProductAttributeKey entity was cleared.
func (m *ProductAttributeValueMutation) KeyCleared() bool {
	return m.KeyIDCleared() || m.clearedkey
}

// KeyIDs returns the "key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyID instead. It exists only for internal usage by the builders.
func (m *ProductAttributeValueMutation) KeyIDs() (ids []int) {
	if id := m.key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKey resets all changes to the "key" edge.
func (m *ProductAttributeValueMutation) ResetKey() {
	m.key = nil
	m.clearedkey = false
}

// AddItemIDs adds the "items" edge to the ProductSpecsItem entity by ids.
func (m *ProductAttributeValueMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ProductSpecsItem entity.
func (m *ProductAttributeValueMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ProductSpecsItem entity was cleared.
func (m *ProductAttributeValueMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ProductSpecsItem entity by IDs.
func (m *ProductAttributeValueMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ProductSpecsItem entity.
func (m *ProductAttributeValueMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ProductAttributeValueMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ProductAttributeValueMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the ProductAttributeValueMutation builder.
func (m *ProductAttributeValueMutation) Where(ps ...predicate.ProductAttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductAttributeValueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAttributeValue).
func (m *ProductAttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productattributevalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productattributevalue.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, productattributevalue.FieldKeyID)
	}
	if m.value != nil {
		fields = append(fields, productattributevalue.FieldValue)
	}
	if m.sort != nil {
		fields = append(fields, productattributevalue.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattributevalue.FieldCreatedAt:
		return m.CreatedAt()
	case productattributevalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case productattributevalue.FieldKeyID:
		return m.KeyID()
	case productattributevalue.FieldValue:
		return m.Value()
	case productattributevalue.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattributevalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productattributevalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productattributevalue.FieldKeyID:
		return m.OldKeyID(ctx)
	case productattributevalue.FieldValue:
		return m.OldValue(ctx)
	case productattributevalue.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattributevalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productattributevalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productattributevalue.FieldKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case productattributevalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case productattributevalue.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttributeValueMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, productattributevalue.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattributevalue.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattributevalue.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttributeValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productattributevalue.FieldCreatedAt) {
		fields = append(fields, productattributevalue.FieldCreatedAt)
	}
	if m.FieldCleared(productattributevalue.FieldUpdatedAt) {
		fields = append(fields, productattributevalue.FieldUpdatedAt)
	}
	if m.FieldCleared(productattributevalue.FieldKeyID) {
		fields = append(fields, productattributevalue.FieldKeyID)
	}
	if m.FieldCleared(productattributevalue.FieldValue) {
		fields = append(fields, productattributevalue.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttributeValueMutation) ClearField(name string) error {
	switch name {
	case productattributevalue.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productattributevalue.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case productattributevalue.FieldKeyID:
		m.ClearKeyID()
		return nil
	case productattributevalue.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttributeValueMutation) ResetField(name string) error {
	switch name {
	case productattributevalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productattributevalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productattributevalue.FieldKeyID:
		m.ResetKeyID()
		return nil
	case productattributevalue.FieldValue:
		m.ResetValue()
		return nil
	case productattributevalue.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.key != nil {
		edges = append(edges, productattributevalue.EdgeKey)
	}
	if m.items != nil {
		edges = append(edges, productattributevalue.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productattributevalue.EdgeKey:
		if id := m.key; id != nil {
			return []ent.Value{*id}
		}
	case productattributevalue.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, productattributevalue.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttributeValueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productattributevalue.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkey {
		edges = append(edges, productattributevalue.EdgeKey)
	}
	if m.cleareditems {
		edges = append(edges, productattributevalue.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case productattributevalue.EdgeKey:
		return m.clearedkey
	case productattributevalue.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case productattributevalue.EdgeKey:
		m.ClearKey()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case productattributevalue.EdgeKey:
		m.ResetKey()
		return nil
	case productattributevalue.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown ProductAttributeValue edge %s", name)
}

// ProductCateMutation represents an operation that mutates the ProductCate nodes in the graph.
type ProductCateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	parent_id       *int
	addparent_id    *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	sort            *int
	addsort         *int
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCate, error)
	predicates      []predicate.ProductCate
}

var _ ent.Mutation = (*ProductCateMutation)(nil)

// productcateOption allows management of the mutation configuration using functional options.
type productcateOption func(*ProductCateMutation)

// newProductCateMutation creates new mutation for the ProductCate entity.
func newProductCateMutation(c config, op Op, opts ...productcateOption) *ProductCateMutation {
	m := &ProductCateMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCateID sets the ID field of the mutation.
func withProductCateID(id int) productcateOption {
	return func(m *ProductCateMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCate
		)
		m.oldValue = func(ctx context.Context) (*ProductCate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCate sets the old ProductCate of the mutation.
func withProductCate(node *ProductCate) productcateOption {
	return func(m *ProductCateMutation) {
		m.oldValue = func(context.Context) (*ProductCate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetParentID sets the "parent_id" field.
func (m *ProductCateMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *ProductCateMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the ProductCate entity.
// If the ProductCate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCateMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *ProductCateMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *ProductCateMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *ProductCateMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[productcate.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *ProductCateMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[productcate.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *ProductCateMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, productcate.FieldParentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCate entity.
// If the ProductCate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductCateMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productcate.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductCateMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productcate.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCateMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productcate.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCate entity.
// If the ProductCate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductCateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productcate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductCateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productcate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productcate.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *ProductCateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductCateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductCate entity.
// If the ProductCate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductCateMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *ProductCateMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ProductCateMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ProductCate entity.
// If the ProductCate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCateMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ProductCateMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ProductCateMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ProductCateMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCateMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCateMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCateMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCateMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCateMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCateMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCateMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCateMutation builder.
func (m *ProductCateMutation) Where(ps ...predicate.ProductCate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductCateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCate).
func (m *ProductCateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.parent_id != nil {
		fields = append(fields, productcate.FieldParentID)
	}
	if m.created_at != nil {
		fields = append(fields, productcate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, productcate.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, productcate.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcate.FieldParentID:
		return m.ParentID()
	case productcate.FieldCreatedAt:
		return m.CreatedAt()
	case productcate.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcate.FieldName:
		return m.Name()
	case productcate.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcate.FieldParentID:
		return m.OldParentID(ctx)
	case productcate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcate.FieldName:
		return m.OldName(ctx)
	case productcate.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcate.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case productcate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productcate.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCateMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, productcate.FieldParentID)
	}
	if m.addsort != nil {
		fields = append(fields, productcate.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productcate.FieldParentID:
		return m.AddedParentID()
	case productcate.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productcate.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case productcate.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcate.FieldParentID) {
		fields = append(fields, productcate.FieldParentID)
	}
	if m.FieldCleared(productcate.FieldCreatedAt) {
		fields = append(fields, productcate.FieldCreatedAt)
	}
	if m.FieldCleared(productcate.FieldUpdatedAt) {
		fields = append(fields, productcate.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCateMutation) ClearField(name string) error {
	switch name {
	case productcate.FieldParentID:
		m.ClearParentID()
		return nil
	case productcate.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productcate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductCate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCateMutation) ResetField(name string) error {
	switch name {
	case productcate.FieldParentID:
		m.ResetParentID()
		return nil
	case productcate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcate.FieldName:
		m.ResetName()
		return nil
	case productcate.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown ProductCate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, productcate.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcate.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, productcate.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcate.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, productcate.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCateMutation) EdgeCleared(name string) bool {
	switch name {
	case productcate.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCateMutation) ResetEdge(name string) error {
	switch name {
	case productcate.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCate edge %s", name)
}

// ProductSpecsMutation represents an operation that mutates the ProductSpecs nodes in the graph.
type ProductSpecsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	sn             *string
	stock          *int
	addstock       *int
	sales          *int
	addsales       *int
	price          *float64
	addprice       *float64
	sale_price     *float64
	addsale_price  *float64
	create_id      *int
	addcreate_id   *int
	clearedFields  map[string]struct{}
	product        *int
	clearedproduct bool
	items          map[int]struct{}
	removeditems   map[int]struct{}
	cleareditems   bool
	done           bool
	oldValue       func(context.Context) (*ProductSpecs, error)
	predicates     []predicate.ProductSpecs
}

var _ ent.Mutation = (*ProductSpecsMutation)(nil)

// productspecsOption allows management of the mutation configuration using functional options.
type productspecsOption func(*ProductSpecsMutation)

// newProductSpecsMutation creates new mutation for the ProductSpecs entity.
func newProductSpecsMutation(c config, op Op, opts ...productspecsOption) *ProductSpecsMutation {
	m := &ProductSpecsMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpecs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecsID sets the ID field of the mutation.
func withProductSpecsID(id int) productspecsOption {
	return func(m *ProductSpecsMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpecs
		)
		m.oldValue = func(ctx context.Context) (*ProductSpecs, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpecs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpecs sets the old ProductSpecs of the mutation.
func withProductSpecs(node *ProductSpecs) productspecsOption {
	return func(m *ProductSpecsMutation) {
		m.oldValue = func(context.Context) (*ProductSpecs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductSpecsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductSpecsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductSpecsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productspecs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductSpecsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productspecs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductSpecsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productspecs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductSpecsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductSpecsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductSpecsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productspecs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductSpecsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productspecs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductSpecsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productspecs.FieldUpdatedAt)
}

// SetProductID sets the "product_id" field.
func (m *ProductSpecsMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductSpecsMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductSpecsMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[productspecs.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductSpecsMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productspecs.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductSpecsMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, productspecs.FieldProductID)
}

// SetName sets the "name" field.
func (m *ProductSpecsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductSpecsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductSpecsMutation) ResetName() {
	m.name = nil
}

// SetSn sets the "sn" field.
func (m *ProductSpecsMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ProductSpecsMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ProductSpecsMutation) ResetSn() {
	m.sn = nil
}

// SetStock sets the "stock" field.
func (m *ProductSpecsMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductSpecsMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductSpecsMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductSpecsMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductSpecsMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetSales sets the "sales" field.
func (m *ProductSpecsMutation) SetSales(i int) {
	m.sales = &i
	m.addsales = nil
}

// Sales returns the value of the "sales" field in the mutation.
func (m *ProductSpecsMutation) Sales() (r int, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSales returns the old "sales" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldSales(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSales is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSales requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSales: %w", err)
	}
	return oldValue.Sales, nil
}

// AddSales adds i to the "sales" field.
func (m *ProductSpecsMutation) AddSales(i int) {
	if m.addsales != nil {
		*m.addsales += i
	} else {
		m.addsales = &i
	}
}

// AddedSales returns the value that was added to the "sales" field in this mutation.
func (m *ProductSpecsMutation) AddedSales() (r int, exists bool) {
	v := m.addsales
	if v == nil {
		return
	}
	return *v, true
}

// ResetSales resets all changes to the "sales" field.
func (m *ProductSpecsMutation) ResetSales() {
	m.sales = nil
	m.addsales = nil
}

// SetPrice sets the "price" field.
func (m *ProductSpecsMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductSpecsMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductSpecsMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductSpecsMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductSpecsMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetSalePrice sets the "sale_price" field.
func (m *ProductSpecsMutation) SetSalePrice(f float64) {
	m.sale_price = &f
	m.addsale_price = nil
}

// SalePrice returns the value of the "sale_price" field in the mutation.
func (m *ProductSpecsMutation) SalePrice() (r float64, exists bool) {
	v := m.sale_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "sale_price" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldSalePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds f to the "sale_price" field.
func (m *ProductSpecsMutation) AddSalePrice(f float64) {
	if m.addsale_price != nil {
		*m.addsale_price += f
	} else {
		m.addsale_price = &f
	}
}

// AddedSalePrice returns the value that was added to the "sale_price" field in this mutation.
func (m *ProductSpecsMutation) AddedSalePrice() (r float64, exists bool) {
	v := m.addsale_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalePrice resets all changes to the "sale_price" field.
func (m *ProductSpecsMutation) ResetSalePrice() {
	m.sale_price = nil
	m.addsale_price = nil
}

// SetCreateID sets the "create_id" field.
func (m *ProductSpecsMutation) SetCreateID(i int) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *ProductSpecsMutation) CreateID() (r int, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the ProductSpecs entity.
// If the ProductSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsMutation) OldCreateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *ProductSpecsMutation) AddCreateID(i int) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *ProductSpecsMutation) AddedCreateID() (r int, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *ProductSpecsMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[productspecs.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *ProductSpecsMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[productspecs.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *ProductSpecsMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, productspecs.FieldCreateID)
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductSpecsMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductSpecsMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductSpecsMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductSpecsMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddItemIDs adds the "items" edge to the ProductSpecsItem entity by ids.
func (m *ProductSpecsMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ProductSpecsItem entity.
func (m *ProductSpecsMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ProductSpecsItem entity was cleared.
func (m *ProductSpecsMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ProductSpecsItem entity by IDs.
func (m *ProductSpecsMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ProductSpecsItem entity.
func (m *ProductSpecsMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ProductSpecsMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ProductSpecsMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the ProductSpecsMutation builder.
func (m *ProductSpecsMutation) Where(ps ...predicate.ProductSpecs) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductSpecsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSpecs).
func (m *ProductSpecsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, productspecs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productspecs.FieldUpdatedAt)
	}
	if m.product != nil {
		fields = append(fields, productspecs.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, productspecs.FieldName)
	}
	if m.sn != nil {
		fields = append(fields, productspecs.FieldSn)
	}
	if m.stock != nil {
		fields = append(fields, productspecs.FieldStock)
	}
	if m.sales != nil {
		fields = append(fields, productspecs.FieldSales)
	}
	if m.price != nil {
		fields = append(fields, productspecs.FieldPrice)
	}
	if m.sale_price != nil {
		fields = append(fields, productspecs.FieldSalePrice)
	}
	if m.create_id != nil {
		fields = append(fields, productspecs.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspecs.FieldCreatedAt:
		return m.CreatedAt()
	case productspecs.FieldUpdatedAt:
		return m.UpdatedAt()
	case productspecs.FieldProductID:
		return m.ProductID()
	case productspecs.FieldName:
		return m.Name()
	case productspecs.FieldSn:
		return m.Sn()
	case productspecs.FieldStock:
		return m.Stock()
	case productspecs.FieldSales:
		return m.Sales()
	case productspecs.FieldPrice:
		return m.Price()
	case productspecs.FieldSalePrice:
		return m.SalePrice()
	case productspecs.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspecs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productspecs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productspecs.FieldProductID:
		return m.OldProductID(ctx)
	case productspecs.FieldName:
		return m.OldName(ctx)
	case productspecs.FieldSn:
		return m.OldSn(ctx)
	case productspecs.FieldStock:
		return m.OldStock(ctx)
	case productspecs.FieldSales:
		return m.OldSales(ctx)
	case productspecs.FieldPrice:
		return m.OldPrice(ctx)
	case productspecs.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case productspecs.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpecs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspecs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productspecs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productspecs.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productspecs.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productspecs.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case productspecs.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case productspecs.FieldSales:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSales(v)
		return nil
	case productspecs.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productspecs.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case productspecs.FieldCreateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecsMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, productspecs.FieldStock)
	}
	if m.addsales != nil {
		fields = append(fields, productspecs.FieldSales)
	}
	if m.addprice != nil {
		fields = append(fields, productspecs.FieldPrice)
	}
	if m.addsale_price != nil {
		fields = append(fields, productspecs.FieldSalePrice)
	}
	if m.addcreate_id != nil {
		fields = append(fields, productspecs.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspecs.FieldStock:
		return m.AddedStock()
	case productspecs.FieldSales:
		return m.AddedSales()
	case productspecs.FieldPrice:
		return m.AddedPrice()
	case productspecs.FieldSalePrice:
		return m.AddedSalePrice()
	case productspecs.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspecs.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case productspecs.FieldSales:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSales(v)
		return nil
	case productspecs.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case productspecs.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	case productspecs.FieldCreateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productspecs.FieldCreatedAt) {
		fields = append(fields, productspecs.FieldCreatedAt)
	}
	if m.FieldCleared(productspecs.FieldUpdatedAt) {
		fields = append(fields, productspecs.FieldUpdatedAt)
	}
	if m.FieldCleared(productspecs.FieldProductID) {
		fields = append(fields, productspecs.FieldProductID)
	}
	if m.FieldCleared(productspecs.FieldCreateID) {
		fields = append(fields, productspecs.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecsMutation) ClearField(name string) error {
	switch name {
	case productspecs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productspecs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case productspecs.FieldProductID:
		m.ClearProductID()
		return nil
	case productspecs.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecsMutation) ResetField(name string) error {
	switch name {
	case productspecs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productspecs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productspecs.FieldProductID:
		m.ResetProductID()
		return nil
	case productspecs.FieldName:
		m.ResetName()
		return nil
	case productspecs.FieldSn:
		m.ResetSn()
		return nil
	case productspecs.FieldStock:
		m.ResetStock()
		return nil
	case productspecs.FieldSales:
		m.ResetSales()
		return nil
	case productspecs.FieldPrice:
		m.ResetPrice()
		return nil
	case productspecs.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case productspecs.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, productspecs.EdgeProduct)
	}
	if m.items != nil {
		edges = append(edges, productspecs.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productspecs.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productspecs.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, productspecs.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productspecs.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, productspecs.EdgeProduct)
	}
	if m.cleareditems {
		edges = append(edges, productspecs.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecsMutation) EdgeCleared(name string) bool {
	switch name {
	case productspecs.EdgeProduct:
		return m.clearedproduct
	case productspecs.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecsMutation) ClearEdge(name string) error {
	switch name {
	case productspecs.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecsMutation) ResetEdge(name string) error {
	switch name {
	case productspecs.EdgeProduct:
		m.ResetProduct()
		return nil
	case productspecs.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecs edge %s", name)
}

// ProductSpecsItemMutation represents an operation that mutates the ProductSpecsItem nodes in the graph.
type ProductSpecsItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	value_id      *int
	addvalue_id   *int
	sort          *int
	addsort       *int
	clearedFields map[string]struct{}
	specs         *int
	clearedspecs  bool
	values        map[int]struct{}
	removedvalues map[int]struct{}
	clearedvalues bool
	done          bool
	oldValue      func(context.Context) (*ProductSpecsItem, error)
	predicates    []predicate.ProductSpecsItem
}

var _ ent.Mutation = (*ProductSpecsItemMutation)(nil)

// productspecsitemOption allows management of the mutation configuration using functional options.
type productspecsitemOption func(*ProductSpecsItemMutation)

// newProductSpecsItemMutation creates new mutation for the ProductSpecsItem entity.
func newProductSpecsItemMutation(c config, op Op, opts ...productspecsitemOption) *ProductSpecsItemMutation {
	m := &ProductSpecsItemMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpecsItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecsItemID sets the ID field of the mutation.
func withProductSpecsItemID(id int) productspecsitemOption {
	return func(m *ProductSpecsItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpecsItem
		)
		m.oldValue = func(ctx context.Context) (*ProductSpecsItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpecsItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpecsItem sets the old ProductSpecsItem of the mutation.
func withProductSpecsItem(node *ProductSpecsItem) productspecsitemOption {
	return func(m *ProductSpecsItemMutation) {
		m.oldValue = func(context.Context) (*ProductSpecsItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecsItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecsItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecsItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductSpecsItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductSpecsItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductSpecsItem entity.
// If the ProductSpecsItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductSpecsItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productspecsitem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductSpecsItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productspecsitem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductSpecsItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productspecsitem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductSpecsItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductSpecsItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductSpecsItem entity.
// If the ProductSpecsItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductSpecsItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productspecsitem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductSpecsItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productspecsitem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductSpecsItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productspecsitem.FieldUpdatedAt)
}

// SetProductSpecsID sets the "product_specs_id" field.
func (m *ProductSpecsItemMutation) SetProductSpecsID(i int) {
	m.specs = &i
}

// ProductSpecsID returns the value of the "product_specs_id" field in the mutation.
func (m *ProductSpecsItemMutation) ProductSpecsID() (r int, exists bool) {
	v := m.specs
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecsID returns the old "product_specs_id" field's value of the ProductSpecsItem entity.
// If the ProductSpecsItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsItemMutation) OldProductSpecsID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductSpecsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductSpecsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecsID: %w", err)
	}
	return oldValue.ProductSpecsID, nil
}

// ClearProductSpecsID clears the value of the "product_specs_id" field.
func (m *ProductSpecsItemMutation) ClearProductSpecsID() {
	m.specs = nil
	m.clearedFields[productspecsitem.FieldProductSpecsID] = struct{}{}
}

// ProductSpecsIDCleared returns if the "product_specs_id" field was cleared in this mutation.
func (m *ProductSpecsItemMutation) ProductSpecsIDCleared() bool {
	_, ok := m.clearedFields[productspecsitem.FieldProductSpecsID]
	return ok
}

// ResetProductSpecsID resets all changes to the "product_specs_id" field.
func (m *ProductSpecsItemMutation) ResetProductSpecsID() {
	m.specs = nil
	delete(m.clearedFields, productspecsitem.FieldProductSpecsID)
}

// SetValueID sets the "value_id" field.
func (m *ProductSpecsItemMutation) SetValueID(i int) {
	m.value_id = &i
	m.addvalue_id = nil
}

// ValueID returns the value of the "value_id" field in the mutation.
func (m *ProductSpecsItemMutation) ValueID() (r int, exists bool) {
	v := m.value_id
	if v == nil {
		return
	}
	return *v, true
}

// OldValueID returns the old "value_id" field's value of the ProductSpecsItem entity.
// If the ProductSpecsItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsItemMutation) OldValueID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueID: %w", err)
	}
	return oldValue.ValueID, nil
}

// AddValueID adds i to the "value_id" field.
func (m *ProductSpecsItemMutation) AddValueID(i int) {
	if m.addvalue_id != nil {
		*m.addvalue_id += i
	} else {
		m.addvalue_id = &i
	}
}

// AddedValueID returns the value that was added to the "value_id" field in this mutation.
func (m *ProductSpecsItemMutation) AddedValueID() (r int, exists bool) {
	v := m.addvalue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearValueID clears the value of the "value_id" field.
func (m *ProductSpecsItemMutation) ClearValueID() {
	m.value_id = nil
	m.addvalue_id = nil
	m.clearedFields[productspecsitem.FieldValueID] = struct{}{}
}

// ValueIDCleared returns if the "value_id" field was cleared in this mutation.
func (m *ProductSpecsItemMutation) ValueIDCleared() bool {
	_, ok := m.clearedFields[productspecsitem.FieldValueID]
	return ok
}

// ResetValueID resets all changes to the "value_id" field.
func (m *ProductSpecsItemMutation) ResetValueID() {
	m.value_id = nil
	m.addvalue_id = nil
	delete(m.clearedFields, productspecsitem.FieldValueID)
}

// SetSort sets the "sort" field.
func (m *ProductSpecsItemMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ProductSpecsItemMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ProductSpecsItem entity.
// If the ProductSpecsItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecsItemMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ProductSpecsItemMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ProductSpecsItemMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ProductSpecsItemMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetSpecsID sets the "specs" edge to the ProductSpecs entity by id.
func (m *ProductSpecsItemMutation) SetSpecsID(id int) {
	m.specs = &id
}

// ClearSpecs clears the "specs" edge to the ProductSpecs entity.
func (m *ProductSpecsItemMutation) ClearSpecs() {
	m.clearedspecs = true
}

// SpecsCleared reports if the "specs" edge to the ProductSpecs entity was cleared.
func (m *ProductSpecsItemMutation) SpecsCleared() bool {
	return m.ProductSpecsIDCleared() || m.clearedspecs
}

// SpecsID returns the "specs" edge ID in the mutation.
func (m *ProductSpecsItemMutation) SpecsID() (id int, exists bool) {
	if m.specs != nil {
		return *m.specs, true
	}
	return
}

// SpecsIDs returns the "specs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpecsID instead. It exists only for internal usage by the builders.
func (m *ProductSpecsItemMutation) SpecsIDs() (ids []int) {
	if id := m.specs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpecs resets all changes to the "specs" edge.
func (m *ProductSpecsItemMutation) ResetSpecs() {
	m.specs = nil
	m.clearedspecs = false
}

// AddValueIDs adds the "values" edge to the ProductAttributeValue entity by ids.
func (m *ProductSpecsItemMutation) AddValueIDs(ids ...int) {
	if m.values == nil {
		m.values = make(map[int]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the ProductAttributeValue entity.
func (m *ProductSpecsItemMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the ProductAttributeValue entity was cleared.
func (m *ProductSpecsItemMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the ProductAttributeValue entity by IDs.
func (m *ProductSpecsItemMutation) RemoveValueIDs(ids ...int) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the ProductAttributeValue entity.
func (m *ProductSpecsItemMutation) RemovedValuesIDs() (ids []int) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *ProductSpecsItemMutation) ValuesIDs() (ids []int) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *ProductSpecsItemMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the ProductSpecsItemMutation builder.
func (m *ProductSpecsItemMutation) Where(ps ...predicate.ProductSpecsItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductSpecsItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductSpecsItem).
func (m *ProductSpecsItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecsItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productspecsitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productspecsitem.FieldUpdatedAt)
	}
	if m.specs != nil {
		fields = append(fields, productspecsitem.FieldProductSpecsID)
	}
	if m.value_id != nil {
		fields = append(fields, productspecsitem.FieldValueID)
	}
	if m.sort != nil {
		fields = append(fields, productspecsitem.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecsItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspecsitem.FieldCreatedAt:
		return m.CreatedAt()
	case productspecsitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case productspecsitem.FieldProductSpecsID:
		return m.ProductSpecsID()
	case productspecsitem.FieldValueID:
		return m.ValueID()
	case productspecsitem.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecsItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspecsitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productspecsitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productspecsitem.FieldProductSpecsID:
		return m.OldProductSpecsID(ctx)
	case productspecsitem.FieldValueID:
		return m.OldValueID(ctx)
	case productspecsitem.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpecsItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecsItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspecsitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productspecsitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productspecsitem.FieldProductSpecsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecsID(v)
		return nil
	case productspecsitem.FieldValueID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueID(v)
		return nil
	case productspecsitem.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecsItemMutation) AddedFields() []string {
	var fields []string
	if m.addvalue_id != nil {
		fields = append(fields, productspecsitem.FieldValueID)
	}
	if m.addsort != nil {
		fields = append(fields, productspecsitem.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecsItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspecsitem.FieldValueID:
		return m.AddedValueID()
	case productspecsitem.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecsItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspecsitem.FieldValueID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValueID(v)
		return nil
	case productspecsitem.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecsItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productspecsitem.FieldCreatedAt) {
		fields = append(fields, productspecsitem.FieldCreatedAt)
	}
	if m.FieldCleared(productspecsitem.FieldUpdatedAt) {
		fields = append(fields, productspecsitem.FieldUpdatedAt)
	}
	if m.FieldCleared(productspecsitem.FieldProductSpecsID) {
		fields = append(fields, productspecsitem.FieldProductSpecsID)
	}
	if m.FieldCleared(productspecsitem.FieldValueID) {
		fields = append(fields, productspecsitem.FieldValueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecsItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecsItemMutation) ClearField(name string) error {
	switch name {
	case productspecsitem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productspecsitem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case productspecsitem.FieldProductSpecsID:
		m.ClearProductSpecsID()
		return nil
	case productspecsitem.FieldValueID:
		m.ClearValueID()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecsItemMutation) ResetField(name string) error {
	switch name {
	case productspecsitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productspecsitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productspecsitem.FieldProductSpecsID:
		m.ResetProductSpecsID()
		return nil
	case productspecsitem.FieldValueID:
		m.ResetValueID()
		return nil
	case productspecsitem.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecsItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.specs != nil {
		edges = append(edges, productspecsitem.EdgeSpecs)
	}
	if m.values != nil {
		edges = append(edges, productspecsitem.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecsItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productspecsitem.EdgeSpecs:
		if id := m.specs; id != nil {
			return []ent.Value{*id}
		}
	case productspecsitem.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecsItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvalues != nil {
		edges = append(edges, productspecsitem.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecsItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productspecsitem.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecsItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedspecs {
		edges = append(edges, productspecsitem.EdgeSpecs)
	}
	if m.clearedvalues {
		edges = append(edges, productspecsitem.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecsItemMutation) EdgeCleared(name string) bool {
	switch name {
	case productspecsitem.EdgeSpecs:
		return m.clearedspecs
	case productspecsitem.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecsItemMutation) ClearEdge(name string) error {
	switch name {
	case productspecsitem.EdgeSpecs:
		m.ClearSpecs()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecsItemMutation) ResetEdge(name string) error {
	switch name {
	case productspecsitem.EdgeSpecs:
		m.ResetSpecs()
		return nil
	case productspecsitem.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecsItem edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	username      *string
	mobile        *string
	pass          *string
	uuid          *uuid.UUID
	role          *int
	addrole       *int
	active        *bool
	state         *user.State
	login         *time.Time
	clearedFields map[string]struct{}
	detail        map[int]struct{}
	removeddetail map[int]struct{}
	cleareddetail bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetPass sets the "pass" field.
func (m *UserMutation) SetPass(s string) {
	m.pass = &s
}

// Pass returns the value of the "pass" field in the mutation.
func (m *UserMutation) Pass() (r string, exists bool) {
	v := m.pass
	if v == nil {
		return
	}
	return *v, true
}

// OldPass returns the old "pass" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPass: %w", err)
	}
	return oldValue.Pass, nil
}

// ClearPass clears the value of the "pass" field.
func (m *UserMutation) ClearPass() {
	m.pass = nil
	m.clearedFields[user.FieldPass] = struct{}{}
}

// PassCleared returns if the "pass" field was cleared in this mutation.
func (m *UserMutation) PassCleared() bool {
	_, ok := m.clearedFields[user.FieldPass]
	return ok
}

// ResetPass resets all changes to the "pass" field.
func (m *UserMutation) ResetPass() {
	m.pass = nil
	delete(m.clearedFields, user.FieldPass)
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ClearRole clears the value of the "role" field.
func (m *UserMutation) ClearRole() {
	m.role = nil
	m.addrole = nil
	m.clearedFields[user.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *UserMutation) RoleCleared() bool {
	_, ok := m.clearedFields[user.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
	delete(m.clearedFields, user.FieldRole)
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetState sets the "state" field.
func (m *UserMutation) SetState(u user.State) {
	m.state = &u
}

// State returns the value of the "state" field in the mutation.
func (m *UserMutation) State() (r user.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldState(ctx context.Context) (v user.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *UserMutation) ClearState() {
	m.state = nil
	m.clearedFields[user.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *UserMutation) StateCleared() bool {
	_, ok := m.clearedFields[user.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *UserMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, user.FieldState)
}

// SetLogin sets the "login" field.
func (m *UserMutation) SetLogin(t time.Time) {
	m.login = &t
}

// Login returns the value of the "login" field in the mutation.
func (m *UserMutation) Login() (r time.Time, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *UserMutation) ResetLogin() {
	m.login = nil
}

// AddDetailIDs adds the "detail" edge to the UserDetail entity by ids.
func (m *UserMutation) AddDetailIDs(ids ...int) {
	if m.detail == nil {
		m.detail = make(map[int]struct{})
	}
	for i := range ids {
		m.detail[ids[i]] = struct{}{}
	}
}

// ClearDetail clears the "detail" edge to the UserDetail entity.
func (m *UserMutation) ClearDetail() {
	m.cleareddetail = true
}

// DetailCleared reports if the "detail" edge to the UserDetail entity was cleared.
func (m *UserMutation) DetailCleared() bool {
	return m.cleareddetail
}

// RemoveDetailIDs removes the "detail" edge to the UserDetail entity by IDs.
func (m *UserMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetail == nil {
		m.removeddetail = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.detail, ids[i])
		m.removeddetail[ids[i]] = struct{}{}
	}
}

// RemovedDetail returns the removed IDs of the "detail" edge to the UserDetail entity.
func (m *UserMutation) RemovedDetailIDs() (ids []int) {
	for id := range m.removeddetail {
		ids = append(ids, id)
	}
	return
}

// DetailIDs returns the "detail" edge IDs in the mutation.
func (m *UserMutation) DetailIDs() (ids []int) {
	for id := range m.detail {
		ids = append(ids, id)
	}
	return
}

// ResetDetail resets all changes to the "detail" edge.
func (m *UserMutation) ResetDetail() {
	m.detail = nil
	m.cleareddetail = false
	m.removeddetail = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.pass != nil {
		fields = append(fields, user.FieldPass)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.state != nil {
		fields = append(fields, user.FieldState)
	}
	if m.login != nil {
		fields = append(fields, user.FieldLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldPass:
		return m.Pass()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldRole:
		return m.Role()
	case user.FieldActive:
		return m.Active()
	case user.FieldState:
		return m.State()
	case user.FieldLogin:
		return m.Login()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldPass:
		return m.OldPass(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldState:
		return m.OldState(ctx)
	case user.FieldLogin:
		return m.OldLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldPass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPass(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldState:
		v, ok := value.(user.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case user.FieldLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldPass) {
		fields = append(fields, user.FieldPass)
	}
	if m.FieldCleared(user.FieldRole) {
		fields = append(fields, user.FieldRole)
	}
	if m.FieldCleared(user.FieldState) {
		fields = append(fields, user.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldPass:
		m.ClearPass()
		return nil
	case user.FieldRole:
		m.ClearRole()
		return nil
	case user.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldPass:
		m.ResetPass()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldState:
		m.ResetState()
		return nil
	case user.FieldLogin:
		m.ResetLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.detail != nil {
		edges = append(edges, user.EdgeDetail)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDetail:
		ids := make([]ent.Value, 0, len(m.detail))
		for id := range m.detail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddetail != nil {
		edges = append(edges, user.EdgeDetail)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDetail:
		ids := make([]ent.Value, 0, len(m.removeddetail))
		for id := range m.removeddetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddetail {
		edges = append(edges, user.EdgeDetail)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDetail:
		return m.cleareddetail
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDetail:
		m.ResetDetail()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDetailMutation represents an operation that mutates the UserDetail nodes in the graph.
type UserDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	age           *int
	addage        *int
	rank          *float64
	addrank       *float64
	pic           *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserDetail, error)
	predicates    []predicate.UserDetail
}

var _ ent.Mutation = (*UserDetailMutation)(nil)

// userdetailOption allows management of the mutation configuration using functional options.
type userdetailOption func(*UserDetailMutation)

// newUserDetailMutation creates new mutation for the UserDetail entity.
func newUserDetailMutation(c config, op Op, opts ...userdetailOption) *UserDetailMutation {
	m := &UserDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDetailID sets the ID field of the mutation.
func withUserDetailID(id int) userdetailOption {
	return func(m *UserDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDetail
		)
		m.oldValue = func(ctx context.Context) (*UserDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDetail sets the old UserDetail of the mutation.
func withUserDetail(node *UserDetail) userdetailOption {
	return func(m *UserDetailMutation) {
		m.oldValue = func(context.Context) (*UserDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the "user_id" field.
func (m *UserDetailMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDetailMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDetail entity.
// If the UserDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDetailMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserDetailMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userdetail.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserDetailMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userdetail.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDetailMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userdetail.FieldUserID)
}

// SetName sets the "name" field.
func (m *UserDetailMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserDetailMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserDetail entity.
// If the UserDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDetailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserDetailMutation) ClearName() {
	m.name = nil
	m.clearedFields[userdetail.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserDetailMutation) NameCleared() bool {
	_, ok := m.clearedFields[userdetail.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserDetailMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, userdetail.FieldName)
}

// SetAge sets the "age" field.
func (m *UserDetailMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserDetailMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the UserDetail entity.
// If the UserDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDetailMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *UserDetailMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserDetailMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "age" field.
func (m *UserDetailMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[userdetail.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *UserDetailMutation) AgeCleared() bool {
	_, ok := m.clearedFields[userdetail.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *UserDetailMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, userdetail.FieldAge)
}

// SetRank sets the "rank" field.
func (m *UserDetailMutation) SetRank(f float64) {
	m.rank = &f
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *UserDetailMutation) Rank() (r float64, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the UserDetail entity.
// If the UserDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDetailMutation) OldRank(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds f to the "rank" field.
func (m *UserDetailMutation) AddRank(f float64) {
	if m.addrank != nil {
		*m.addrank += f
	} else {
		m.addrank = &f
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *UserDetailMutation) AddedRank() (r float64, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ClearRank clears the value of the "rank" field.
func (m *UserDetailMutation) ClearRank() {
	m.rank = nil
	m.addrank = nil
	m.clearedFields[userdetail.FieldRank] = struct{}{}
}

// RankCleared returns if the "rank" field was cleared in this mutation.
func (m *UserDetailMutation) RankCleared() bool {
	_, ok := m.clearedFields[userdetail.FieldRank]
	return ok
}

// ResetRank resets all changes to the "rank" field.
func (m *UserDetailMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
	delete(m.clearedFields, userdetail.FieldRank)
}

// SetPic sets the "pic" field.
func (m *UserDetailMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *UserDetailMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the UserDetail entity.
// If the UserDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDetailMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *UserDetailMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[userdetail.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *UserDetailMutation) PicCleared() bool {
	_, ok := m.clearedFields[userdetail.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *UserDetailMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, userdetail.FieldPic)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDetailMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDetailMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDetailMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDetailMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserDetailMutation builder.
func (m *UserDetailMutation) Where(ps ...predicate.UserDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserDetail).
func (m *UserDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, userdetail.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, userdetail.FieldName)
	}
	if m.age != nil {
		fields = append(fields, userdetail.FieldAge)
	}
	if m.rank != nil {
		fields = append(fields, userdetail.FieldRank)
	}
	if m.pic != nil {
		fields = append(fields, userdetail.FieldPic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdetail.FieldUserID:
		return m.UserID()
	case userdetail.FieldName:
		return m.Name()
	case userdetail.FieldAge:
		return m.Age()
	case userdetail.FieldRank:
		return m.Rank()
	case userdetail.FieldPic:
		return m.Pic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdetail.FieldUserID:
		return m.OldUserID(ctx)
	case userdetail.FieldName:
		return m.OldName(ctx)
	case userdetail.FieldAge:
		return m.OldAge(ctx)
	case userdetail.FieldRank:
		return m.OldRank(ctx)
	case userdetail.FieldPic:
		return m.OldPic(ctx)
	}
	return nil, fmt.Errorf("unknown UserDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdetail.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdetail.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userdetail.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case userdetail.FieldRank:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case userdetail.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	}
	return fmt.Errorf("unknown UserDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDetailMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, userdetail.FieldAge)
	}
	if m.addrank != nil {
		fields = append(fields, userdetail.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdetail.FieldAge:
		return m.AddedAge()
	case userdetail.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdetail.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case userdetail.FieldRank:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown UserDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userdetail.FieldUserID) {
		fields = append(fields, userdetail.FieldUserID)
	}
	if m.FieldCleared(userdetail.FieldName) {
		fields = append(fields, userdetail.FieldName)
	}
	if m.FieldCleared(userdetail.FieldAge) {
		fields = append(fields, userdetail.FieldAge)
	}
	if m.FieldCleared(userdetail.FieldRank) {
		fields = append(fields, userdetail.FieldRank)
	}
	if m.FieldCleared(userdetail.FieldPic) {
		fields = append(fields, userdetail.FieldPic)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDetailMutation) ClearField(name string) error {
	switch name {
	case userdetail.FieldUserID:
		m.ClearUserID()
		return nil
	case userdetail.FieldName:
		m.ClearName()
		return nil
	case userdetail.FieldAge:
		m.ClearAge()
		return nil
	case userdetail.FieldRank:
		m.ClearRank()
		return nil
	case userdetail.FieldPic:
		m.ClearPic()
		return nil
	}
	return fmt.Errorf("unknown UserDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDetailMutation) ResetField(name string) error {
	switch name {
	case userdetail.FieldUserID:
		m.ResetUserID()
		return nil
	case userdetail.FieldName:
		m.ResetName()
		return nil
	case userdetail.FieldAge:
		m.ResetAge()
		return nil
	case userdetail.FieldRank:
		m.ResetRank()
		return nil
	case userdetail.FieldPic:
		m.ResetPic()
		return nil
	}
	return fmt.Errorf("unknown UserDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userdetail.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdetail.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userdetail.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case userdetail.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDetailMutation) ClearEdge(name string) error {
	switch name {
	case userdetail.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDetailMutation) ResetEdge(name string) error {
	switch name {
	case userdetail.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserDetail edge %s", name)
}
